# HG changeset patch
# Parent 06197260bdbb3ee9d53e1f602245448deda30314

diff -r 06197260bdbb .hgignore
--- a/.hgignore
+++ b/.hgignore
@@ -243,6 +243,7 @@
 ^tools/vtpm/tpm_emulator/.*$
 ^tools/vtpm/vtpm/.*$
 ^tools/vtpm_manager/manager/vtpm_managerd$
+^tools/xenguest/xenguest$
 ^tools/xcutils/lsevtchn$
 ^tools/xcutils/xc_restore$
 ^tools/xcutils/xc_save$
diff -r 06197260bdbb mk/xen-4.4.spec.in
--- a/mk/xen-4.4.spec.in
+++ b/mk/xen-4.4.spec.in
@@ -420,6 +420,7 @@ rm -rf $RPM_BUILD_ROOT
 %{_libdir}/%{name}/bin/xc_save
 %{_libdir}/%{name}/bin/xenconsole
 %{_libdir}/%{name}/bin/xenctx
+%{_libdir}/%{name}/bin/xenguest
 %{_libdir}/%{name}/bin/xenpaging
 %{_libdir}/%{name}/bin/xenpvnetboot
 
diff -r 06197260bdbb tools/Makefile
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -22,6 +22,7 @@ SUBDIRS-$(CONFIG_NetBSD) += xenbackendd
 SUBDIRS-y += libfsimage
 SUBDIRS-$(LIBXENAPI_BINDINGS) += libxen
 SUBDIRS-$(CONFIG_Linux) += libvchan
+SUBDIRS-y += xenguest
 
 # do not recurse in to a dir we are about to delete
 ifneq "$(MAKECMDGOALS)" "distclean"
diff -r 06197260bdbb tools/xenguest/Makefile
--- /dev/null
+++ b/tools/xenguest/Makefile
@@ -0,0 +1,29 @@
+XEN_ROOT=$(CURDIR)/../..
+include $(XEN_ROOT)/tools/Rules.mk
+
+CFLAGS += -Werror
+CFLAGS += -I.
+CFLAGS += $(CFLAGS_libxenctrl) $(CFLAGS_libguest) $(CFLAGS_libxenstore)
+CFLAGS += -D_GNU_SOURCE -D_BSD_SOURCE
+
+PROGRAMS := xenguest
+
+.PHONY: all
+all: build
+
+.PHONY: build
+build: $(PROGRAMS)
+
+xenguest: xenguest.o xenguest_stubs.o xenguest_posix.c
+	$(CC) $(CFLAGS) -o $@ $(LDFLAGS) $^ -pthread \
+		$(LDLIBS_libxenctrl) $(LDLIBS_libxenguest) $(LDLIBS_libxenstore)
+
+.PHONY: install
+install: build
+	$(INSTALL_DIR) $(DESTDIR)$(PRIVATE_BINDIR)
+	$(INSTALL_PROG) $(PROGRAMS) $(DESTDIR)$(PRIVATE_BINDIR)
+
+.PHONY: clean
+clean:
+	$(RM) *.o $(ALL_TARGETS)
+	$(RM) $(DEPS)
diff -r 06197260bdbb tools/xenguest/xenguest.c
--- /dev/null
+++ b/tools/xenguest/xenguest.c
@@ -0,0 +1,630 @@
+#include <getopt.h>
+#include <errno.h>
+#include <syslog.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <fcntl.h>
+
+#include <xenctrl.h>
+#include <xenguest.h>
+#include <xenstore.h>
+
+#include "xg_internal.h"
+
+/*
+ * Xapi uses a strange protocol to communicate which xenguest, which seems to
+ * be a relic from the xend days.
+ *
+ * For all domain functions, Xapi expects on the controloutfd:
+ *
+ *   result:<xenstore mfn> <console mfn>[ <PV ABI>]\n
+ *
+ * with the xenstore and console mfn in decimal and a PV ABI for PV domains
+ * only; HVM domains only require the two mfns.  This information is only
+ * relevent when constructing and restoring domains, but must be present for
+ * suspend as well, with 0 for both MFNs and no ABI.
+ *
+ * In addition for suspend only, Xapi expects to see the string "suspend:\n"
+ * written to the controloutfd, and expects xenguest to wait until it
+ * successfully reads a line from controlinfd.
+ */
+
+enum xenguest_opts {
+    XG_OPT_MODE, /* choice */
+    XG_OPT_CONTROLINFD, /* int */
+    XG_OPT_CONTROLOUTFD, /* int */
+    XG_OPT_DEBUGLOG, /* str */
+    XG_OPT_FAKE, /* bool */
+    XG_OPT_FD, /* int */
+    XG_OPT_IMAGE, /* str */
+    XG_OPT_CMDLINE, /* str */
+    XG_OPT_RAMDISK, /* str */
+    XG_OPT_DOMID, /* int */
+    XG_OPT_LIVE, /* bool */
+    XG_OPT_DEBUG, /* bool */
+    XG_OPT_STORE_PORT, /* str */
+    XG_OPT_STORE_DOMID, /* str */
+    XG_OPT_CONSOLE_PORT, /* str */
+    XG_OPT_CONSOLE_DOMID, /* str */
+    XG_OPT_FEATURES, /* str */
+    XG_OPT_FLAGS, /* int */
+    XG_OPT_MEM_MAX_MIB, /* int */
+    XG_OPT_MEM_START_MIB, /* int */
+    XG_OPT_FORK, /* bool */
+    XG_OPT_NO_INC_GENID, /* bool */
+    XG_OPT_LEGACY_STREAM, /* bool */
+};
+
+static int opt_mode = -1;
+static int opt_controlinfd = -1;
+static int opt_controloutfd = -1;
+static FILE *opt_debugfile = NULL;
+static int opt_fd = -1;
+static const char *opt_image = NULL;
+static const char *opt_cmdline = NULL;
+static const char *opt_ramdisk = NULL;
+static int opt_domid = -1;
+static int opt_store_port = -1;
+static int opt_store_domid = -1;
+static int opt_console_port = -1;
+static int opt_console_domid = -1;
+static const char *opt_features = NULL;
+static int opt_flags = 0;
+static int opt_mem_max_mib = -1;
+static int opt_mem_start_mib = -1;
+static bool opt_legacy_stream = false;
+
+static const char *xg_mode_names[] = {
+    [XG_MODE_SAVE] = "save",
+    [XG_MODE_HVM_SAVE] = "hvm_save",
+    [XG_MODE_RESTORE] = "restore",
+    [XG_MODE_HVM_RESTORE] = "hvm_restore",
+    [XG_MODE_RESUME_SLOW] = "resume_slow",
+    [XG_MODE_LINUX_BUILD] = "linux_build",
+    [XG_MODE_HVM_BUILD] = "hvm_build",
+    [XG_MODE_TEST] = "test",
+};
+
+static pthread_mutex_t logging_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+void err(const char *msg, ...)
+{
+    char *buf = NULL;
+    va_list args;
+    int rc;
+
+    va_start(args, msg);
+    rc = vasprintf(&buf, msg, args);
+    va_end(args);
+
+    if ( rc != -1 )
+    {
+        pthread_mutex_lock(&logging_mutex);
+
+        if ( opt_debugfile )
+            fputs(buf, opt_debugfile);
+        fputs(buf, stderr);
+        syslog(LOG_ERR|LOG_DAEMON, "%s", buf);
+
+        pthread_mutex_unlock(&logging_mutex);
+    }
+
+    free(buf);
+}
+
+void info(const char *msg, ...)
+{
+    char *buf = NULL;
+    va_list args;
+    int rc;
+
+    va_start(args, msg);
+    rc = vasprintf(&buf, msg, args);
+    va_end(args);
+
+    if ( rc != -1 )
+    {
+        pthread_mutex_lock(&logging_mutex);
+
+        if ( opt_debugfile )
+            fputs(buf, opt_debugfile);
+        syslog(LOG_INFO|LOG_DAEMON, "%s", buf);
+
+        pthread_mutex_unlock(&logging_mutex);
+    }
+
+    free(buf);
+}
+
+static void logfn(struct xentoollog_logger *logger,
+                  xentoollog_level level,
+                  int errnoval,
+                  const char *context,
+                  const char *format,
+                  va_list al)
+{
+    char *buf = NULL;
+
+    if ( level == XTL_DEBUG && !(opt_flags & XCFLAGS_DEBUG) )
+        return;
+
+    if ( vasprintf(&buf, format, al) != -1 )
+        info("%s: %s: %s\n", context, xtl_level_to_string(level), buf);
+
+    free(buf);
+}
+
+static int parse_mode(const char *mode)
+{
+    int i;
+
+    for (i = 0; i < XG_MODE__END__; i++) {
+        if (strcmp(mode, xg_mode_names[i]) == 0)
+            return i;
+    }
+    err("xenguest: unrecognized mode '%s'\n", mode);
+    exit(1);
+}
+
+static int parse_int(const char *str)
+{
+    char *end;
+    int result;
+
+    result = strtol(str, &end, 10);
+
+    if (*end != '\0') {
+        err("xenguest: '%s' is not a valid integer\n", str);
+        exit(1);
+    }
+
+    return result;
+}
+
+static void parse_options(int argc, char *const argv[])
+{
+    static const struct option opts[] = {
+        { "mode", required_argument, NULL, XG_OPT_MODE, },
+        { "controlinfd", required_argument, NULL, XG_OPT_CONTROLINFD, },
+        { "controloutfd", required_argument, NULL, XG_OPT_CONTROLOUTFD, },
+        { "debuglog", required_argument, NULL, XG_OPT_DEBUGLOG, },
+        { "fake", no_argument, NULL, XG_OPT_FAKE, },
+
+        { "fd", required_argument, NULL, XG_OPT_FD, },
+        { "image", required_argument, NULL, XG_OPT_IMAGE, },
+        { "cmdline", required_argument, NULL, XG_OPT_CMDLINE, },
+        { "ramdisk", required_argument, NULL, XG_OPT_RAMDISK, },
+        { "domid", required_argument, NULL, XG_OPT_DOMID, },
+        { "live", no_argument, NULL, XG_OPT_LIVE, },
+        { "debug", no_argument, NULL, XG_OPT_DEBUG, },
+        { "store_port", required_argument, NULL, XG_OPT_STORE_PORT, },
+        { "store_domid", required_argument, NULL, XG_OPT_STORE_DOMID, },
+        { "console_port", required_argument, NULL, XG_OPT_CONSOLE_PORT, },
+        { "console_domid", required_argument, NULL, XG_OPT_CONSOLE_DOMID, },
+        { "features", required_argument, NULL, XG_OPT_FEATURES, },
+        { "flags", required_argument, NULL, XG_OPT_FLAGS, },
+        { "mem_max_mib", required_argument, NULL, XG_OPT_MEM_MAX_MIB, },
+        { "mem_start_mib", required_argument, NULL, XG_OPT_MEM_START_MIB, },
+        { "fork", no_argument, NULL, XG_OPT_FORK, },
+        { "no_incr_generationid", no_argument, NULL, XG_OPT_NO_INC_GENID, },
+        { "legacy_stream", required_argument, NULL, XG_OPT_LEGACY_STREAM, },
+        { NULL },
+    };
+
+    int c;
+
+    for(;;) {
+        int option_index = 0;
+
+        c = getopt_long_only(argc, argv, "", opts, &option_index);
+
+        switch (c) {
+        case -1:
+            return;
+
+        case XG_OPT_MODE:
+            opt_mode = parse_mode(optarg);
+            break;
+
+        case XG_OPT_CONTROLINFD:
+            opt_controlinfd = parse_int(optarg);
+            break;
+
+        case XG_OPT_CONTROLOUTFD:
+            opt_controloutfd = parse_int(optarg);
+            break;
+
+        case XG_OPT_DEBUGLOG:
+            opt_debugfile = fopen(optarg, "a");
+            if ( !opt_debugfile )
+                err("Unable to open debug file\n");
+            break;
+
+        case XG_OPT_FD:
+            opt_fd = parse_int(optarg);
+            break;
+
+        case XG_OPT_IMAGE:
+            opt_image = optarg;
+            break;
+
+        case XG_OPT_CMDLINE:
+            opt_cmdline = optarg;
+            break;
+
+        case XG_OPT_RAMDISK:
+            opt_ramdisk = optarg;
+            break;
+
+        case XG_OPT_DOMID:
+            opt_domid = parse_int(optarg);
+            break;
+
+        case XG_OPT_LIVE:
+            opt_flags |= XCFLAGS_LIVE;
+            break;
+
+        case XG_OPT_DEBUG:
+            opt_flags |= XCFLAGS_DEBUG;
+            break;
+
+        case XG_OPT_STORE_PORT:
+            opt_store_port = parse_int(optarg);
+            break;
+
+        case XG_OPT_STORE_DOMID:
+            opt_store_domid = parse_int(optarg);
+            break;
+
+        case XG_OPT_CONSOLE_PORT:
+            opt_console_port = parse_int(optarg);
+            break;
+
+        case XG_OPT_CONSOLE_DOMID:
+            opt_console_domid = parse_int(optarg);
+            break;
+
+        case XG_OPT_FEATURES:
+            opt_features = optarg;
+            break;
+
+        case XG_OPT_FLAGS:
+            opt_flags = parse_int(optarg);
+            break;
+
+        case XG_OPT_MEM_MAX_MIB:
+            opt_mem_max_mib = parse_int(optarg);
+            break;
+
+        case XG_OPT_MEM_START_MIB:
+            opt_mem_start_mib = parse_int(optarg);
+            break;
+
+        case XG_OPT_FAKE:
+        case XG_OPT_FORK:
+        case XG_OPT_NO_INC_GENID:
+            /* ignored */
+            break;
+
+        case XG_OPT_LEGACY_STREAM:
+            opt_legacy_stream = !!parse_int(optarg);
+            break;
+
+        default:
+            err("xenguest: invalid command line\n");
+            exit(1);
+        }
+    }
+}
+
+static void set_cloexec(int fd)
+{
+    int flags = fcntl(fd, F_GETFD);
+
+    if ( fcntl(fd, flags | FD_CLOEXEC) == -1 )
+    {
+        err("Failed to set FD_CLOEXEC on fd %d: %d %s",
+            fd, errno, strerror(errno));
+        exit(1);
+    }
+}
+
+static void write_status(unsigned long store_mfn, unsigned long console_mfn,
+                         const char *protocol)
+{
+    char buf[64];
+    size_t len;
+
+    if (protocol)
+        len = snprintf(buf, sizeof(buf), "result:%lu %lu %s\n", store_mfn, console_mfn, protocol);
+    else
+        len = snprintf(buf, sizeof(buf), "result:%lu %lu\n", store_mfn, console_mfn);
+    write(opt_controloutfd, buf, len);
+    info("Writing to control: %s", buf);
+}
+
+static void do_save(xc_interface *xch, xs_handle *xsh, bool is_hvm)
+{
+    if (opt_domid == -1 || opt_fd == -1) {
+        err("xenguest: missing command line options\n");
+        exit(1);
+    }
+
+    stub_xc_domain_save(xch, xsh, opt_fd, opt_domid, 0, 0, opt_flags, is_hvm);
+    write_status(0, 0, NULL);
+}
+
+static void do_restore(xc_interface *xch, xs_handle *xsh, bool is_hvm)
+{
+    unsigned long store_mfn = 0, console_mfn = 0;
+
+    if (opt_domid == -1 || opt_fd == -1
+        || opt_store_port == -1 || opt_console_port == -1) {
+        err("xenguest: missing command line options\n");
+        exit(1);
+    }
+
+    /*
+     * For a legacy incoming stream, we need to fork ourselves the converstion
+     * script and replumb the pipe fds.
+     */
+    if ( opt_legacy_stream )
+    {
+        info("Performing conversion of legacy stream");
+        setup_legacy_conversion(opt_fd, opt_mode);
+    }
+
+    stub_xc_domain_restore(xch, xsh, opt_fd, opt_domid, opt_store_port, opt_console_port, is_hvm,
+                           &store_mfn, &console_mfn);
+
+    if ( opt_legacy_stream )
+        cleanup_legacy_conversion();
+
+    write_status(store_mfn, console_mfn, NULL);
+}
+
+static void do_resume(xc_interface *xch, xs_handle *xsh)
+{
+    if (opt_domid == -1) {
+        err("xenguest: missing command line options\n");
+        exit(1);
+    }
+
+    stub_xc_domain_resume_slow(xch, xsh, opt_domid);
+    write_status(0, 0, NULL);
+}
+
+int suspend_callback(int domid)
+{
+    static const char suspend_message[] = "suspend:\n";
+
+    if (domid == opt_domid) {
+        write(opt_controloutfd, suspend_message, sizeof(suspend_message)-1);
+
+        /* Read one line from control fd. */
+        for (;;) {
+            char buf[1];
+            int len;
+
+            len = read(opt_controlinfd, buf, sizeof(buf));
+            if (len < 0 && errno == EINTR)
+                continue;
+            if (len < 0) {
+                err("xenguest: read from control FD failed: %s\n", strerror(errno));
+                break;
+            }
+            if (len == 0) {
+                err("xenguest: unexpected EOF on control FD\n", strerror(errno));
+                break;
+            }
+            if (buf[0] == '\n')
+                break;
+        }
+        return 1;
+    }
+    return 0;
+}
+
+static void do_linux_build(xc_interface *xch, xs_handle *xsh)
+{
+    unsigned long store_mfn = 0, console_mfn = 0;
+    char protocol[64];
+
+    if (opt_domid == -1 || opt_mem_max_mib == -1 || opt_mem_start_mib == -1
+        || !opt_image || !opt_ramdisk || !opt_cmdline
+        || !opt_features || opt_flags == -1
+        || opt_store_port == -1 || opt_store_domid == -1
+        || opt_console_port == -1 || opt_console_domid == -1) {
+        err("xenguest: missing command line options\n");
+        exit(1);
+    }
+
+    stub_xc_linux_build(xch, xsh, opt_domid,
+                        opt_mem_max_mib, opt_mem_start_mib,
+                        opt_image, opt_ramdisk,
+                        opt_cmdline, opt_features, opt_flags,
+                        opt_store_port, opt_store_domid,
+                        opt_console_port, opt_console_domid,
+                        &store_mfn, &console_mfn, protocol);
+    write_status(store_mfn, console_mfn, protocol);
+}
+
+static void do_hvm_build(xc_interface *xch, xs_handle *xsh)
+{
+    unsigned long store_mfn = 0, console_mfn = 0;
+
+    if (opt_domid == -1 || opt_mem_max_mib == -1 || opt_mem_start_mib == -1
+        || !opt_image || opt_store_port == -1 || opt_store_domid == -1
+        || opt_console_port == -1 || opt_console_domid == -1) {
+        err("xenguest: missing command line options\n");
+        exit(1);
+    }
+
+    stub_xc_hvm_build(xch, xsh, opt_domid, opt_mem_max_mib, opt_mem_start_mib,
+                      opt_image, opt_store_port, opt_store_domid,
+                      opt_console_port, opt_console_domid, &store_mfn,
+                      &console_mfn);
+    write_status(store_mfn, console_mfn, NULL);
+}
+
+static void do_test(xc_interface *xch, xs_handle *xsh)
+{
+    err("xenguest: test mode not supported\n");
+    exit(1);
+}
+
+int main(int argc, char * const argv[])
+{
+    static char ident[32];
+    char *cmdline = NULL;
+    static xentoollog_logger logger = { logfn, NULL, NULL };
+    xc_interface *xch;
+    xs_handle * xsh;
+
+    {   /* Conjoin the command line into a single string for logging */
+        size_t sum, s;
+        int i;
+        char *ptr;
+
+        sum = argc-1; /* Account for spaces and null */
+        for ( i = 1; i < argc; ++i )
+            sum += strlen(argv[i]);
+
+        ptr = cmdline = malloc(sum);
+
+        for ( i = 1; i < argc; ++i )
+        {
+            s = strlen(argv[i]);
+            memcpy(ptr, argv[i], s);
+            ptr[s] = ' ';
+            ptr = &ptr[s+1];
+        }
+        ptr[-1] = 0;
+    }
+
+    parse_options(argc, argv);
+
+    /* Set up syslog with the domid and action in the ident string */
+    if ( opt_domid >= 0 )
+    {
+        const char *suffix;
+
+        switch ( opt_mode )
+        {
+        case XG_MODE_SAVE:
+        case XG_MODE_HVM_SAVE:
+            suffix = "-save";
+            break;
+
+        case XG_MODE_RESTORE:
+        case XG_MODE_HVM_RESTORE:
+            suffix = "-restore";
+            break;
+
+        case XG_MODE_RESUME_SLOW:
+            suffix = "-resume";
+            break;
+
+        case XG_MODE_LINUX_BUILD:
+        case XG_MODE_HVM_BUILD:
+            suffix = "-build";
+            break;
+
+        default:
+            suffix = "";
+            break;
+        }
+
+        snprintf(ident, sizeof ident, "xenguest-%d%s", opt_domid, suffix);
+    }
+    else
+        strncpy(ident, "xenguest", sizeof ident);
+
+    openlog(ident, LOG_NDELAY, LOG_DAEMON);
+
+    info("Command line: %s\n", cmdline);
+    free(cmdline);
+
+    set_cloexec(opt_controlinfd);
+    set_cloexec(opt_controloutfd);
+
+    xch = xc_interface_open(&logger, &logger, 0);
+    if ( !xch ) {
+        err("xenguest: Failed to open xc interface\n");
+        exit(1);
+    }
+
+    xsh = xs_open(0);
+    if ( !xsh ) {
+        err("xenguest: Failed to open xenstore interface\n");
+        exit(1);
+    }
+
+    if ( opt_domid > 0 )
+    {
+        xs_domain_path = xs_get_domain_path(xsh, opt_domid);
+
+        if ( !xs_domain_path )
+        {
+            err("Failed to obtain XenStore domain path\n");
+            exit(1);
+        }
+    }
+
+    switch (opt_mode) {
+    case -1:
+        err("xenguest: no `-mode' option specified\n");
+        exit(1);
+
+    case XG_MODE_SAVE:
+    case XG_MODE_HVM_SAVE:
+        do_save(xch, xsh, opt_mode == XG_MODE_HVM_SAVE);
+        break;
+
+    case XG_MODE_RESTORE:
+    case XG_MODE_HVM_RESTORE:
+        do_restore(xch, xsh, opt_mode == XG_MODE_HVM_RESTORE);
+        break;
+
+    case XG_MODE_RESUME_SLOW:
+        do_resume(xch, xsh);
+        break;
+
+    case XG_MODE_LINUX_BUILD:
+        do_linux_build(xch, xsh);
+        break;
+
+    case XG_MODE_HVM_BUILD:
+        do_hvm_build(xch, xsh);
+        break;
+
+    case XG_MODE_TEST:
+        do_test(xch, xsh);
+        break;
+    }
+
+    free(xs_domain_path);
+
+    xs_close(xsh);
+    xc_interface_close(xch);
+
+    info("All done\n");
+    if ( opt_debugfile )
+        fclose(opt_debugfile);
+    return 0;
+}
+
+/*
+ * Local variables:
+ * mode: C
+ * c-file-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r 06197260bdbb tools/xenguest/xenguest_posix.c
--- /dev/null
+++ b/tools/xenguest/xenguest_posix.c
@@ -0,0 +1,271 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <assert.h>
+
+#include <unistd.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+#include <poll.h>
+
+#include <xenctrl.h>
+#include "xg_internal.h"
+
+#define CHK_SYSCALL(call) ({                                            \
+            if ( (call) == -1 ) {                                       \
+                err("FATAL: '%s' failed: %d %s\n",                      \
+                    #call, errno, strerror(errno));                     \
+                exit(1);                                                \
+            } })
+
+static int stdout_pipe[2], stderr_pipe[2], data_pipe[2];
+static pid_t child;
+static pthread_t logging_thread;
+static bool child_alive;
+
+struct stdbuffer
+{
+    char buffer[2048];
+    unsigned prod, cons;
+    bool valid_line;
+} stdoutbuf, stderrbuf;
+
+static void check_for_line(struct stdbuffer *buf)
+{
+    char *nl;
+
+    /* assert(buf->cons == 0); */
+    if ( buf->cons != 0 )
+    {
+        err("cons %u - bailing", buf->cons);
+        exit(1);
+    }
+
+    nl = strchr(buf->buffer, '\n');
+
+    if ( nl )
+    {
+        buf->valid_line = true;
+        nl[0] = '\0';
+        buf->cons = nl + 1 - buf->buffer;
+    }
+    else if ( buf->prod == (sizeof buf->buffer - 1) )
+    {
+        buf->valid_line = true;
+        strcpy(&buf->buffer[sizeof buf->buffer - 4], "...\0");
+        buf->cons = buf->prod;
+    }
+    else
+        buf->valid_line = false;
+
+    /* info("cfl() = %u, prod %u, cons %u", buf->valid_line, buf->prod, buf->cons); */
+}
+
+static int read_into_buffer(int fd, struct stdbuffer *buf)
+{
+    ssize_t nr;
+
+    /* info("rib()..."); */
+
+    /* assert(buf->prod < (sizeof buf->buffer - 1)); */
+    if ( buf->prod >= (sizeof buf->buffer - 1) )
+    {
+        err("prod %u - bailing", buf->prod);
+        exit(1);
+    }
+
+    nr = read(fd, &buf->buffer[buf->prod], sizeof buf->buffer - buf->prod);
+
+    if ( nr < 0 )
+    {
+        if ( errno != EAGAIN )
+            err("failed read: %d %s", errno, strerror(errno));
+    }
+    else
+        buf->prod += nr;
+    check_for_line(buf);
+
+    /* info("... %ld", nr); */
+
+    return nr;
+}
+
+static void advance_buffer(struct stdbuffer *buf)
+{
+    /* info("advancing: cons %u, prod %u", buf->cons, buf->prod); */
+
+    memmove(buf->buffer, &buf->buffer[buf->cons], buf->prod - buf->cons);
+    memset(&buf->buffer[buf->prod - buf->cons], 0, buf->prod - buf->cons);
+
+    buf->prod -= buf->cons;
+    buf->cons = 0;
+
+    check_for_line(buf);
+}
+
+static void *logging_loop(void *arg)
+{
+    int rc, status;
+    struct pollfd fds[] =
+    {
+        { stdout_pipe[0], POLLIN | POLLRDHUP },
+        { stderr_pipe[0], POLLIN | POLLRDHUP },
+    };
+
+    assert(child_alive);
+
+    while ( child_alive )
+    {
+        rc = poll(fds, sizeof fds / sizeof fds[0], -1);
+
+        if ( rc < 0 )
+        {
+            err("poll() returned %d %s", errno, strerror(errno));
+            exit(1);
+        }
+
+        if ( (fds[0].revents | fds[1].revents) & POLLHUP )
+        {
+            info("Child exited - reaping\n");
+
+            CHK_SYSCALL(waitpid(child, &status, 0));
+
+            if ( WIFEXITED(status) )
+                info("wait complete: exit %d\n", WEXITSTATUS(status));
+            else if ( WIFSIGNALED(status) )
+                err("wait complete: terminated by signal %d", WTERMSIG(status));
+
+            child_alive = false;
+        }
+
+        if ( fds[0].revents & POLLIN )
+        {
+            while ( read_into_buffer(fds[0].fd, &stdoutbuf) > 0 )
+            {
+                while ( stdoutbuf.valid_line )
+                {
+                    info("conv: %s\n", stdoutbuf.buffer);
+                    advance_buffer(&stdoutbuf);
+                }
+            }
+        }
+
+        if ( fds[1].revents & POLLIN )
+        {
+            while ( read_into_buffer(fds[1].fd, &stderrbuf) > 0 )
+            {
+                while ( stderrbuf.valid_line )
+                {
+                    err("conv: %s\n", stderrbuf.buffer);
+                    advance_buffer(&stderrbuf);
+                }
+            }
+        }
+
+    }
+
+    return NULL;
+}
+
+void atexit_reap_child(void)
+{
+    int status;
+
+    if ( child_alive )
+    {
+        kill(child, SIGTERM);
+        waitpid(child, &status, 0);
+        child_alive = false;
+    }
+}
+
+void setup_legacy_conversion(int opt_fd, enum xenguest_mode opt_mode)
+{
+    CHK_SYSCALL(pipe2(stdout_pipe, O_NONBLOCK));
+    CHK_SYSCALL(pipe2(stderr_pipe, O_NONBLOCK));
+    CHK_SYSCALL(pipe(data_pipe));
+
+    /* info("stdout pipe: %d %d\n", stdout_pipe[0], stdout_pipe[1]); */
+    /* info("stderr pipe: %d %d\n", stderr_pipe[0], stderr_pipe[1]); */
+    /* info("data pipe: %d %d\n", data_pipe[0], data_pipe[1]); */
+    /* info("child pipe: %d %d\n", child_pipe[0], child_pipe[1]); */
+
+    child_alive = true;
+    CHK_SYSCALL(child = fork());
+
+    if ( child != 0 )
+    {   /* Parent process */
+        CHK_SYSCALL(close(stdout_pipe[1]));
+        CHK_SYSCALL(close(stderr_pipe[1]));
+        CHK_SYSCALL(close(data_pipe[1]));
+
+        /* Close our input pipe and replace it with the output from conversion. */
+        CHK_SYSCALL(dup2(data_pipe[0], opt_fd));
+
+        atexit(atexit_reap_child);
+
+        if ( pthread_create(&logging_thread, NULL, &logging_loop, NULL) != 0 )
+        {
+            err("pthread_create() failed ;(\n");
+            exit(1);
+        }
+    }
+    else
+    {   /* Child process.  Set up pipes and exec the conversion script */
+        int devnull;
+        char infd[16] = "", outfd[16] = "";
+        char *argv[] =
+            {
+                "legacy.py",
+                "--in", infd,
+                "--out", outfd,
+                "--width", getenv("XG_CONV_64TS") ? "64" : "32",
+                "--guest", opt_mode == XG_MODE_RESTORE ? "pv" : "hvm",
+                NULL
+            };
+
+        CHK_SYSCALL(close(stdout_pipe[0]));
+        CHK_SYSCALL(close(stderr_pipe[0]));
+        CHK_SYSCALL(close(data_pipe[0]));
+
+        CHK_SYSCALL(devnull = open("/dev/null", O_RDONLY));
+
+        /* Hook stdin/out/err */
+        CHK_SYSCALL(dup2(devnull, 0));
+        CHK_SYSCALL(dup2(stdout_pipe[1], 1));
+        CHK_SYSCALL(dup2(stderr_pipe[1], 2));
+
+        CHK_SYSCALL(close(devnull));
+
+        /* Contruct fd references for script */
+        snprintf(infd, sizeof infd, "%d", opt_fd);
+        snprintf(outfd, sizeof outfd, "%d", data_pipe[1]);
+
+        CHK_SYSCALL(execv("/usr/lib64/xen/bin/legacy.py", argv));
+    }
+}
+
+void cleanup_legacy_conversion(void)
+{
+    int rc = pthread_join(logging_thread, NULL);
+
+    if ( rc != 0 )
+        err("pthread_join() failed: %d", rc);
+
+    CHK_SYSCALL(close(stdout_pipe[0]));
+    CHK_SYSCALL(close(stderr_pipe[0]));
+}
+
+/*
+ * Local variables:
+ * mode: C
+ * c-file-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r 06197260bdbb tools/xenguest/xenguest_stubs.c
--- /dev/null
+++ b/tools/xenguest/xenguest_stubs.c
@@ -0,0 +1,598 @@
+/*
+ * Copyright (C) 2006-2009 Citrix Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation; version 2.1 only. with the special
+ * exception on linking described in file LICENSE.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <inttypes.h>
+
+#include <errno.h>
+#include <sys/mman.h>
+
+#include <xenctrl.h>
+#include <xenguest.h>
+#include <xenstore.h>
+#include <xc_dom.h>
+#include <xen/hvm/hvm_info_table.h>
+#include <xen/hvm/params.h>
+#include <xen/hvm/e820.h>
+
+#include "xg_internal.h"
+
+char *xs_domain_path = NULL;
+
+/* The following boolean flags are all set by their value
+   in the platform area of xenstore. The only value that
+   is considered true is the string 'true' */
+struct flags {
+    int vcpus;
+    int vcpus_current;
+    char** vcpu_affinity; /* 0 means unset */
+    uint16_t vcpu_weight;   /* 0 means unset (0 is an illegal weight) */
+    uint16_t vcpu_cap;      /* 0 is default (no cap) */
+    int nx;
+    int viridian;
+    int pae;
+    int acpi;
+    int apic;
+    int acpi_s3;
+    int acpi_s4;
+    int tsc_mode;
+    int hpet;
+    int nested_hvm;
+};
+
+static char *
+xenstore_getsv(xs_handle *xsh, int domid, const char *fmt, va_list ap)
+{
+    char *s = NULL;
+    int n, m;
+    char key[1024] = { 0 };
+
+    n = snprintf(key, sizeof(key), "%s/", xs_domain_path);
+    if (n < 0)
+        goto out;
+    m = vsnprintf(key + n, sizeof(key) - n, fmt, ap);
+    if (m < 0)
+        goto out;
+
+    s = xs_read(xsh, XBT_NULL, key, NULL);
+out:
+    return s;
+}
+
+static char *
+xenstore_gets(xs_handle *xsh, int domid, const char *fmt, ...)
+{
+    char *s;
+    va_list ap;
+
+    va_start(ap, fmt);
+    s = xenstore_getsv(xsh, domid, fmt, ap);
+    va_end(ap);
+    return s;
+}
+
+static uint64_t
+xenstore_get(xs_handle *xsh, int domid, const char *fmt, ...)
+{
+    char *s;
+    uint64_t value = 0;
+    va_list ap;
+
+    va_start(ap, fmt);
+    s = xenstore_getsv(xsh, domid, fmt, ap);
+    if (s) {
+        if (!strcasecmp(s, "true"))
+            value = 1;
+        else
+        {
+            errno = 0;
+            value = strtoull(s, NULL, 0);
+            if ( errno )
+                value = 0;
+        }
+        free(s);
+    }
+    va_end(ap);
+    return value;
+}
+
+static int
+xenstore_putsv(xs_handle *xsh, int domid, const char *_key, const char *fmt, ...)
+{
+    int n, m, rc = -1;
+    char key[512], val[512];
+    va_list ap;
+
+    n = snprintf(key, sizeof(key), "%s/%s", xs_domain_path, _key);
+    if (n < 0)
+        goto out;
+
+    va_start(ap, fmt);
+    m = vsnprintf(val, sizeof(val), fmt, ap);
+    va_end(ap);
+    if (m < 0)
+        goto out;
+
+    rc = xs_write(xsh, XBT_NULL, key, val, strlen(val));
+out:
+    return rc;
+}
+
+static int
+xenstore_puts(xs_handle *xsh, int domid, const char *key, const char *val)
+{
+    return xenstore_putsv(xsh, domid, key, "%s", val);
+}
+
+static int hvmloader_flag(xs_handle *xsh, int domid, const char *key)
+{
+    /* Params going to hvmloader need to convert "true" -> '1' as Xapi gets
+     * this wrong when migrating from older hosts. */
+
+    char *val = xenstore_gets(xsh, domid, key);
+    int ret = -1;
+
+    if ( val )
+    {
+        if ( !strcmp(val, "1") )
+        {
+            ret = 1;
+            goto out;
+        }
+        else if ( !strcmp(val, "0") )
+        {
+            ret = 0;
+            goto out;
+        }
+        if ( !strcasecmp(val, "true") )
+            ret = 1;
+        else
+        {
+            errno = 0;
+            ret = strtol(val, NULL, 0);
+            if ( errno )
+                ret = 0;
+        }
+
+        err("HVMLoader error: Fixing up key '%s' from '%s' to '%d'", key, val, ret);
+        xenstore_putsv(xsh, domid, key, "%d", !!ret);
+    }
+    else
+        xenstore_puts(xsh, domid, key, "0");
+
+ out:
+    free(val);
+    return ret;
+}
+
+static void
+get_flags(xs_handle *xsh, struct flags *f, int domid)
+{
+    char * tmp;
+    int n;
+    f->vcpus = xenstore_get(xsh, domid, "platform/vcpu/number");
+    f->vcpu_affinity = malloc(sizeof(char*) * f->vcpus);
+
+    for (n = 0; n < f->vcpus; n++) {
+        f->vcpu_affinity[n] = xenstore_gets(xsh, domid, "platform/vcpu/%d/affinity", n);
+    }
+    f->vcpus_current = xenstore_get(xsh, domid, "platform/vcpu/current");
+    f->vcpu_weight = xenstore_get(xsh, domid, "platform/vcpu/weight");
+    f->vcpu_cap = xenstore_get(xsh, domid, "platform/vcpu/cap");
+    f->nx       = xenstore_get(xsh, domid, "platform/nx");
+    f->viridian = xenstore_get(xsh, domid, "platform/viridian");
+    f->apic     = xenstore_get(xsh, domid, "platform/apic");
+    f->pae      = xenstore_get(xsh, domid, "platform/pae");
+    f->tsc_mode = xenstore_get(xsh, domid, "platform/tsc_mode");
+    f->nested_hvm = xenstore_get(xsh, domid, "platform/exp-nested-hvm");
+
+    /* Params going to hvmloader - need to convert "true" -> '1' as Xapi gets
+     * this wrong when migrating from older hosts. */
+    f->acpi    = hvmloader_flag(xsh, domid, "platform/acpi");
+    f->acpi_s4 = hvmloader_flag(xsh, domid, "platform/acpi_s4");
+    f->acpi_s3 = hvmloader_flag(xsh, domid, "platform/acpi_s3");
+
+    /*
+     * HACK - Migrated VMs wont have this xs key set, so the naive action
+     * would result in the HPET mysteriously disappearing.  If the key is not
+     * present then enable the hpet to match its default.
+     */
+    tmp = xenstore_gets(xsh, domid, "platform/hpet");
+    if ( tmp && strlen(tmp) )
+        f->hpet = xenstore_get(xsh, domid, "platform/hpet");
+    else
+        f->hpet = 1;
+    free(tmp);
+
+    info("Determined the following parameters from xenstore:\n");
+    info("vcpu/number:%d vcpu/weight:%d vcpu/cap:%d nx: %d viridian: %d "
+         "apic: %d acpi: %d pae: %d acpi_s4: %d acpi_s3: %d tsc_mode: %d "
+         "hpet: %d\n",
+         f->vcpus, f->vcpu_weight, f->vcpu_cap, f->nx, f->viridian, f->apic,
+         f->acpi, f->pae, f->acpi_s4, f->acpi_s3, f->tsc_mode, f->hpet);
+    for (n = 0; n < f->vcpus; n++){
+        info("vcpu/%d/affinity:%s\n", n, (f->vcpu_affinity[n])?f->vcpu_affinity[n]:"unset");
+    }
+}
+
+static void free_flags(struct flags *f)
+{
+    int n;
+    for ( n = 0; n < f->vcpus; ++n )
+        free(f->vcpu_affinity[n]);
+    free(f->vcpu_affinity);
+}
+
+static void failwith_oss_xc(xc_interface *xch, char *fct)
+{
+    char buf[80];
+    const xc_error *error;
+
+    error = xc_get_last_error(xch);
+    if (error->code == XC_ERROR_NONE)
+        snprintf(buf, 80, "%s: [%d] %s", fct, errno, strerror(errno));
+    else
+        snprintf(buf, 80, "%s: [%d] %s", fct, error->code, error->message);
+    xc_clear_last_error(xch);
+    err("xenguest: %s\n", buf);
+    exit(1);
+}
+
+extern struct xc_dom_image *xc_dom_allocate(xc_interface *xch, const char *cmdline, const char *features);
+
+static void configure_vcpus(xc_interface *xch, int domid, struct flags f){
+    struct xen_domctl_sched_credit sdom;
+    int i, j, r, size, pcpus_supplied, min;
+    xc_cpumap_t cpumap;
+
+    size = xc_get_cpumap_size(xch) * 8; /* array is of uint8_t */
+
+    for (i=0; i<f.vcpus; i++){
+        if (f.vcpu_affinity[i]){ /* NULL means unset */
+            pcpus_supplied = strlen(f.vcpu_affinity[i]);
+            min = (pcpus_supplied < size)?pcpus_supplied:size;
+            cpumap = xc_cpumap_alloc(xch);
+            if (cpumap == NULL)
+                failwith_oss_xc(xch, "xc_cpumap_alloc");
+
+            for (j=0; j<min; j++) {
+                if (f.vcpu_affinity[i][j] == '1')
+                    cpumap[j/8] |= 1 << (j&7);
+            }
+            r = xc_vcpu_setaffinity(xch, domid, i, cpumap);
+            free(cpumap);
+            if (r) {
+                failwith_oss_xc(xch, "xc_vcpu_setaffinity");
+            }
+        }
+    }
+
+    r = xc_sched_credit_domain_get(xch, domid, &sdom);
+    /* This should only happen when a different scheduler is set */
+    if (r) {
+        info("Failed to get credit scheduler parameters: scheduler not enabled?\n");
+        return;
+    }
+    if (f.vcpu_weight != 0L) sdom.weight = f.vcpu_weight;
+    if (f.vcpu_cap != 0L) sdom.cap = f.vcpu_cap;
+    /* This shouldn't fail, if "get" above succeeds. This error is fatal
+       to highlight the need to investigate further. */
+    r = xc_sched_credit_domain_set(xch, domid, &sdom);
+    if (r)
+        failwith_oss_xc(xch, "xc_sched_credit_domain_set");
+}
+
+static void configure_tsc(xc_interface *xch, int domid, struct flags f){
+    xc_domain_set_tsc_info(xch, domid, f.tsc_mode, 0, 0, 0);
+}
+
+
+int stub_xc_linux_build(xc_interface *xch, xs_handle *xsh, int domid,
+                        int c_mem_max_mib, int mem_start_mib,
+                        const char *image_name, const char *ramdisk_name,
+                        const char *cmdline, const char *features,
+                        int flags, int store_evtchn, int store_domid,
+                        int console_evtchn, int console_domid,
+                        unsigned long *store_mfn, unsigned long *console_mfn,
+                        char *protocol)
+{
+    int r;
+    struct xc_dom_image *dom;
+
+    struct flags f;
+    get_flags(xsh, &f, domid);
+
+    xc_dom_loginit(xch);
+    dom = xc_dom_allocate(xch, cmdline, features);
+    if (!dom)
+        failwith_oss_xc(xch, "xc_dom_allocate");
+
+    configure_vcpus(xch, domid, f);
+    configure_tsc(xch, domid, f);
+
+    r = xc_dom_linux_build(xch, dom, domid, mem_start_mib,
+                           image_name, ramdisk_name, flags,
+                           store_evtchn, store_mfn,
+                           console_evtchn, console_mfn);
+
+    if (r == 0)
+        r = xc_dom_gnttab_seed(xch, domid,
+                               *console_mfn, *store_mfn,
+                               console_domid, store_domid);
+
+
+    strncpy(protocol, xc_domain_get_native_protocol(xch, domid), 64);
+
+    free_flags(&f);
+    xc_dom_release(dom);
+
+    if (r != 0)
+        failwith_oss_xc(xch, "xc_dom_linux_build");
+
+    return 0;
+}
+
+
+static int hvm_build_set_params(xc_interface *xch, int domid,
+                                int store_evtchn, unsigned long *store_mfn,
+                                int console_evtchn, unsigned long *console_mfn,
+                                struct flags f)
+{
+    struct hvm_info_table *va_hvm;
+    uint8_t *va_map, sum;
+    uint32_t i;
+
+    va_map = xc_map_foreign_range(xch, domid,
+                                  XC_PAGE_SIZE, PROT_READ | PROT_WRITE,
+                                  HVM_INFO_PFN);
+    if (va_map == NULL)
+        return -1;
+
+    va_hvm = (struct hvm_info_table *)(va_map + HVM_INFO_OFFSET);
+    va_hvm->apic_mode = f.apic;
+    va_hvm->nr_vcpus = f.vcpus;
+    memset(va_hvm->vcpu_online, 0, sizeof(va_hvm->vcpu_online));
+    for (i = 0; i < f.vcpus_current; i++)
+        va_hvm->vcpu_online[i/8] |= 1 << (i % 8);
+    va_hvm->checksum = 0;
+    for (i = 0, sum = 0; i < va_hvm->length; i++)
+        sum += ((uint8_t *) va_hvm)[i];
+    va_hvm->checksum = -sum;
+    munmap(va_map, XC_PAGE_SIZE);
+
+    xc_get_hvm_param(xch, domid, HVM_PARAM_STORE_PFN, store_mfn);
+    xc_set_hvm_param(xch, domid, HVM_PARAM_PAE_ENABLED, f.pae);
+    xc_set_hvm_param(xch, domid, HVM_PARAM_VIRIDIAN, f.viridian);
+    xc_set_hvm_param(xch, domid, HVM_PARAM_STORE_EVTCHN, store_evtchn);
+    xc_set_hvm_param(xch, domid, HVM_PARAM_HPET_ENABLED, f.hpet);
+    xc_set_hvm_param(xch, domid, HVM_PARAM_NESTEDHVM, f.nested_hvm);
+    xc_set_hvm_param(xch, domid, HVM_PARAM_NX_ENABLED, f.nx);
+    xc_get_hvm_param(xch, domid, HVM_PARAM_CONSOLE_PFN, console_mfn);
+    xc_set_hvm_param(xch, domid, HVM_PARAM_CONSOLE_EVTCHN, console_evtchn);
+    return 0;
+}
+
+int stub_xc_hvm_build(xc_interface *xch, xs_handle *xsh, int domid,
+                      int mem_max_mib, int mem_start_mib, const char *image_name,
+                      int store_evtchn, int store_domid,
+                      int console_evtchn, int console_domid,
+                      unsigned long *store_mfn, unsigned long *console_mfn)
+{
+    int r;
+    struct flags f;
+    get_flags(xsh, &f, domid);
+
+    configure_vcpus(xch, domid, f);
+    configure_tsc(xch, domid, f);
+
+    r = xc_hvm_build_target_mem(xch, domid,
+                                mem_max_mib,
+                                mem_start_mib,
+                                image_name);
+    if (r)
+        failwith_oss_xc(xch, "hvm_build");
+
+    r = hvm_build_set_params(xch, domid, store_evtchn, store_mfn,
+                             console_evtchn, console_mfn, f);
+    if (r)
+        failwith_oss_xc(xch, "hvm_build_params");
+
+    xc_dom_gnttab_hvm_seed(xch, domid, *console_mfn, *store_mfn,
+                           console_domid, store_domid);
+
+    free_flags(&f);
+
+    return 0;
+}
+
+struct save_callbacks_data
+{
+    xs_handle *xsh;
+    int domid;
+};
+
+static int dispatch_suspend(void *_data)
+{
+    struct save_callbacks_data * data = _data;
+
+    err("dispatch_suspend debug: _data %p", _data);
+    err("dispatch_suspend debug:  data->xsh %p, data->domid %d", data->xsh, data->domid);
+
+    return suspend_callback(data->domid);
+}
+
+static int switch_qemu_logdirty(int domid, unsigned enable, void *_data)
+{
+    struct save_callbacks_data * data = _data;
+    char *path = NULL;
+    bool rc;
+
+    err("qemu_logdirty debug: domid %d, enable %u, _data %p", domid, enable, _data);
+    err("qemu_logdirty debug:   data->xsh %p, data->domid %d", data->xsh, data->domid);
+
+    asprintf(&path, "/local/domain/0/device-model/%u/logdirty/cmd", data->domid);
+
+    if (enable)
+        rc = xs_write(data->xsh, XBT_NULL, path, "enable", strlen("enable"));
+    else
+        rc = xs_write(data->xsh, XBT_NULL, path, "disable", strlen("disable"));
+
+    free(path);
+    return rc ? 0 : 1;
+
+}
+
+#define GENERATION_ID_ADDRESS "hvmloader/generation-id-address"
+
+int stub_xc_domain_save(xc_interface *xch, xs_handle *xsh, int fd, int domid,
+                        int max_iters, int max_factors,
+                        int flags, int hvm)
+{
+    int r;
+    struct save_callbacks_data cb_data =
+        { xsh, domid };
+    struct save_callbacks callbacks =
+        {
+            .suspend = dispatch_suspend,
+            .switch_qemu_logdirty = switch_qemu_logdirty,
+            .data = &cb_data
+        };
+
+    err("stub save debug: cb_data %p, data->xsh %p, data->domid %d",
+        &cb_data, (&cb_data)->xsh, (&cb_data)->domid);
+
+    r = xc_domain_save(xch, fd, domid,
+                       max_iters, max_factors,
+                       flags, &callbacks, hvm);
+    if (r)
+        failwith_oss_xc(xch, "xc_domain_save");
+
+    return 0;
+}
+
+/* this is the slow version of resume for uncooperative domain,
+ * the fast version is available in close source xc */
+int stub_xc_domain_resume_slow(xc_interface *xch, xs_handle *xsh, int domid)
+{
+    int r;
+
+    /* hard code fast to 0, we only want to expose the slow version here */
+    r = xc_domain_resume(xch, domid, 0);
+    if (r)
+        failwith_oss_xc(xch, "xc_domain_resume");
+    return 0;
+}
+
+static int set_genid(xc_interface *xch, xs_handle *xsh, int domid)
+{
+    uint64_t paddr;
+    void *vaddr;
+    char *genid_val_str;
+    char *end;
+    uint64_t genid[2];
+    int rc = -1;
+
+    xc_get_hvm_param(xch, domid, HVM_PARAM_VM_GENERATION_ID_ADDR, &paddr);
+    if (paddr == 0)
+        return 0;
+
+    genid_val_str = xenstore_gets(xsh, domid, "platform/generation-id");
+
+    errno = 0;
+    genid[0] = strtoull(genid_val_str, &end, 0);
+    genid[1] = 0;
+    if ( end && end[0] == ':' )
+        genid[1] = strtoull(end+1, NULL, 0);
+
+    if ( errno )
+    {
+        err("strtoull of '%s' failed: %s\n", genid_val_str, strerror(errno));
+        goto out;
+    }
+    else if ( genid[0] == 0 || genid[1] == 0 )
+    {
+        err("'%s' is not a valid generation id", genid_val_str);
+        goto out;
+    }
+
+    vaddr = xc_map_foreign_range(xch, domid, XC_PAGE_SIZE,
+                                 PROT_READ | PROT_WRITE,
+                                 paddr >> XC_PAGE_SHIFT);
+    if (vaddr == NULL) {
+        err("Failed to map VM generation ID page: %s", strerror(errno));
+        goto out;
+    }
+    memcpy(vaddr + (paddr & ~XC_PAGE_MASK), genid, 2 * sizeof(*genid));
+    munmap(vaddr, XC_PAGE_SIZE);
+
+    /*
+     * FIXME: Inject ACPI Notify event.
+     */
+
+    info("Wrote generation ID %"PRId64":%"PRId64" at 0x%"PRIx64,
+         genid[0], genid[1], paddr);
+    rc = 0;
+
+ out:
+    free(genid_val_str);
+    return rc;
+}
+
+int stub_xc_domain_restore(xc_interface *xch, xs_handle *xsh, int fd, int domid,
+                           int store_evtchn, int console_evtchn,
+                           int hvm,
+                           unsigned long *store_mfn, unsigned long *console_mfn)
+{
+    int r;
+    struct flags f;
+
+    get_flags(xsh, &f, domid);
+
+    if ( hvm )
+    {
+        xc_set_hvm_param(xch, domid, HVM_PARAM_VIRIDIAN, f.viridian);
+        xc_set_hvm_param(xch, domid, HVM_PARAM_HPET_ENABLED, f.hpet);
+    }
+
+    configure_vcpus(xch, domid, f);
+
+    r = xc_domain_restore(xch, fd, domid,
+                          store_evtchn, store_mfn, 0,
+                          console_evtchn, console_mfn, 0,
+                          hvm, f.pae, 0, 0, NULL);
+
+    free_flags(&f);
+    if (r)
+        failwith_oss_xc(xch, "xc_domain_restore");
+
+    r = set_genid(xch, xsh, domid);
+    if (r)
+        exit(1);
+
+    return 0;
+}
+
+/*
+ * Local variables:
+ * mode: C
+ * c-file-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r 06197260bdbb tools/xenguest/xg_internal.h
--- /dev/null
+++ b/tools/xenguest/xg_internal.h
@@ -0,0 +1,59 @@
+#ifndef __XG_INTERNAL_H__
+#define __XG_INTERNAL_H__
+
+enum xenguest_mode {
+    XG_MODE_SAVE,
+    XG_MODE_HVM_SAVE,
+    XG_MODE_RESTORE,
+    XG_MODE_HVM_RESTORE,
+    XG_MODE_RESUME_SLOW,
+    XG_MODE_LINUX_BUILD,
+    XG_MODE_HVM_BUILD,
+    XG_MODE_TEST,
+    XG_MODE__END__,
+};
+
+void err(const char *msg, ...);
+void info(const char *msg, ...);
+
+typedef struct xs_handle xs_handle;
+
+int stub_xc_linux_build(xc_interface *xch, xs_handle *xsh, int domid,
+                        int c_mem_max_mib, int mem_start_mib,
+                        const char *image_name, const char *ramdisk_name,
+                        const char *cmdline, const char *features,
+                        int flags, int store_evtchn, int store_domid,
+                        int console_evtchn, int console_domid,
+                        unsigned long *store_mfn, unsigned long *console_mfn,
+                        char *protocol);
+int stub_xc_hvm_build(xc_interface *xch, xs_handle *xsh, int domid,
+                      int mem_max_mib, int mem_start_mib, const char *image_name,
+                      int store_evtchn, int store_domid, int console_evtchn,
+                      int console_domid, unsigned long *store_mfn, unsigned long *console_mfn);
+int stub_xc_domain_save(xc_interface *xch, xs_handle *xsh, int fd, int domid,
+                        int max_iters, int max_factors,
+                        int flags, int hvm);
+int stub_xc_domain_restore(xc_interface *xch, xs_handle *xsh, int fd, int domid,
+                           int store_evtchn, int console_evtchn,
+                           int hvm,
+                           unsigned long *store_mfn, unsigned long *console_mfn);
+int stub_xc_domain_resume_slow(xc_interface *xch, xs_handle *xsh, int domid);
+
+int suspend_callback(int domid);
+
+void setup_legacy_conversion(int opt_fd, enum xenguest_mode mode);
+void cleanup_legacy_conversion(void);
+
+extern char *xs_domain_path;
+
+#endif
+
+/*
+ * Local variables:
+ * mode: C
+ * c-file-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
