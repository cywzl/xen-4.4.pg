Miscellaneous change for new save/restore

- use void* for p2m to avoid using without casting;
- use uint32_t for pfn_types to reduce memory usage;
- do not change for specific processor is possible to make code
  more portable.

diff -r 5ba0434a4adf tools/libxc/saverestore/common.h
--- a/tools/libxc/saverestore/common.h	Mon Apr 07 15:32:40 2014 +0100
+++ b/tools/libxc/saverestore/common.h	Mon Apr 07 15:32:42 2014 +0100
@@ -84,12 +84,15 @@ struct context
 
             /* Number of frames making up the p2m */
             unsigned int p2m_frames;
-            /* Read-only guests phys to machine map */
-            xen_pfn_t *p2m;
+            /* Read-only guests phys to machine map
+             * Could be 32 or 64 bit depending on guest
+             * This can be either mapped (save) or allocated (restore)
+             */
+            void *p2m;
             /* The guest pfns containing the p2m leaves */
             xen_pfn_t *p2m_pfns;
             /* Types for each page */
-            xen_pfn_t *pfn_types;
+            uint32_t *pfn_types;
 
             /* Read-only mapping of guests shared info page */
             shared_info_any_t *shinfo;
diff -r 5ba0434a4adf tools/libxc/saverestore/common_x86_pv.c
--- a/tools/libxc/saverestore/common_x86_pv.c	Mon Apr 07 15:32:40 2014 +0100
+++ b/tools/libxc/saverestore/common_x86_pv.c	Mon Apr 07 15:32:42 2014 +0100
@@ -10,44 +10,25 @@ xen_pfn_t mfn_to_pfn(struct context *ctx
 
 xen_pfn_t pfn_to_mfn(struct context *ctx, xen_pfn_t pfn)
 {
+    xen_pfn_t mfn;
+
     assert(pfn <= ctx->x86_pv.max_pfn);
 
-    if ( ctx->x86_pv.width == sizeof (unsigned long) )
-        return ctx->x86_pv.p2m[pfn];
-    else
-    {
-#ifdef __x86_64__
-        /* 64bit toolstack, 32bit guest.  Extend MFN_INVALID to 64 bits */
-        if ( ((uint32_t*)ctx->x86_pv.p2m)[pfn] == ~0U )
-            return -1ULL;
-        else
-            return ((uint32_t*)ctx->x86_pv.p2m)[pfn];
-#else
-        /* 32bit toolstack, 64bit guest.  Reduce their pointers */
-        return ((uint64_t*)ctx->x86_pv.p2m)[pfn];
-#endif
-    }
+    if ( ctx->x86_pv.width == sizeof (uint64_t) )
+        return ((const uint64_t*)ctx->x86_pv.p2m)[pfn];
+
+    mfn = ((const uint32_t*)ctx->x86_pv.p2m)[pfn];
+    return mfn == ~0U ? INVALID_MFN : mfn;
 }
 
 void set_p2m(struct context *ctx, xen_pfn_t pfn, xen_pfn_t mfn)
 {
     assert(pfn <= ctx->x86_pv.max_pfn);
 
-    if ( ctx->x86_pv.width == sizeof (unsigned long) )
-        ctx->x86_pv.p2m[pfn] = mfn;
+    if ( ctx->x86_pv.width == sizeof (uint64_t) )
+        ((uint64_t*)ctx->x86_pv.p2m)[pfn] = mfn == INVALID_MFN ? ~0ULL : mfn;
     else
-    {
-#ifdef __x86_64__
-        /* 64bit toolstack, 32bit guest.  Discard top 32 bits of mfn */
-        ((uint32_t*)ctx->x86_pv.p2m)[pfn] = (uint32_t)mfn;
-#else
-        /* 32bit toolstack, 64bit guest.  Extend MFN_INVALID */
-        if ( mfn == INVALID_MFN )
-            ((uint64_t*)ctx->x86_pv.p2m)[pfn] = -1ULL;
-        else
-            ((uint64_t*)ctx->x86_pv.p2m)[pfn] = (uint64_t)mfn;
-#endif
-    }
+        ((uint32_t*)ctx->x86_pv.p2m)[pfn] = mfn;
 }
 
 bool mfn_in_pseudophysmap(struct context *ctx, xen_pfn_t mfn)
@@ -73,7 +54,7 @@ void pseudophysmap_walk(struct context *
 
     if ( (pfn != ~0UL) && (pfn <= ctx->x86_pv.max_pfn) )
         ERROR("  p2m[%#lx] = %#lx",
-              pfn, ctx->x86_pv.p2m[pfn]);
+              pfn, pfn_to_mfn(ctx, pfn));
 }
 
 xen_pfn_t cr3_to_mfn(struct context *ctx, uint64_t cr3)
diff -r 5ba0434a4adf tools/libxc/saverestore/restore.c
--- a/tools/libxc/saverestore/restore.c	Mon Apr 07 15:32:40 2014 +0100
+++ b/tools/libxc/saverestore/restore.c	Mon Apr 07 15:32:42 2014 +0100
@@ -103,6 +103,7 @@ int xc_domain_restore2(xc_interface *xch
     }
     else
     {
+        // FIXME this assume x86 even on ARM, should be restore_arch(&ctx)
         if ( restore_x86_pv(&ctx) )
             return -1;
 
diff -r 5ba0434a4adf tools/libxc/saverestore/restore_x86_pv.c
--- a/tools/libxc/saverestore/restore_x86_pv.c	Mon Apr 07 15:32:40 2014 +0100
+++ b/tools/libxc/saverestore/restore_x86_pv.c	Mon Apr 07 15:32:42 2014 +0100
@@ -9,7 +9,8 @@ static int expand_p2m(struct context *ct
     unsigned long old_max = ctx->x86_pv.max_pfn, i;
     unsigned long end_frame = (max_pfn + ctx->x86_pv.fpp) / ctx->x86_pv.fpp;
     unsigned long old_end_frame = (old_max + ctx->x86_pv.fpp) / ctx->x86_pv.fpp;
-    xen_pfn_t *p2m = NULL, *p2m_pfns = NULL, *pfn_types = NULL;
+    xen_pfn_t *p2m = NULL, *p2m_pfns = NULL;
+    uint32_t *pfn_types = NULL;
     size_t p2msz, p2m_pfnsz, pfn_typesz;
 
     /* We expect expand_p2m to be called exactly once, expanding from 0 the
@@ -396,6 +397,14 @@ static int handle_page_data(struct conte
             rc = localise_pagetable(ctx, guest_page, type);
             if ( rc )
                 goto cleanup;
+            break;
+
+        case XEN_DOMCTL_PFINFO_NOTAB:
+            break;
+
+        default:
+            ERROR("Bad pfn %#lx, type %#lx", pfn, type);
+            goto cleanup;
     }
 
     rc = 0;
@@ -493,7 +502,7 @@ static int handle_x86_pv_p2m_frames(stru
     }
 
     start =  data->start_pfn / ctx->x86_pv.fpp;
-    end = (data->end_pfn + ctx->x86_pv.fpp) / ctx->x86_pv.fpp;
+    end = data->end_pfn / ctx->x86_pv.fpp + 1;
 
     if ( rec->length != sizeof *data + ((end - start) * sizeof (uint64_t)) )
     {
diff -r 5ba0434a4adf tools/libxc/saverestore/save_x86_pv.c
--- a/tools/libxc/saverestore/save_x86_pv.c	Mon Apr 07 15:32:40 2014 +0100
+++ b/tools/libxc/saverestore/save_x86_pv.c	Mon Apr 07 15:32:42 2014 +0100
@@ -59,6 +59,18 @@ static int map_shinfo(struct context *ct
     return 0;
 }
 
+static void pfn_guest2local(unsigned int guest_width, xen_pfn_t *dst, const void *src, int entries)
+{
+    int x;
+
+    if ( guest_width == sizeof(uint64_t) )
+        for ( x = 0; x < entries; ++x )
+            dst[x] = ((const uint64_t*)src)[x];
+    else
+        for ( x = 0; x < entries; ++x )
+            dst[x] = ((const uint32_t*)src)[x];
+}
+
 static int map_p2m(struct context *ctx)
 {
     /* Terminology:
@@ -109,7 +121,7 @@ static int map_p2m(struct context *ctx)
         goto err;
     }
 
-    local_fll_size = fll_entries * sizeof(unsigned long);
+    local_fll_size = fll_entries * sizeof(*local_fll);
     local_fll = malloc(local_fll_size);
     if ( !local_fll )
     {
@@ -118,20 +130,7 @@ static int map_p2m(struct context *ctx)
         goto err;
     }
 
-    if ( ctx->x86_pv.width == sizeof(unsigned long) )
-        memcpy(local_fll, guest_fll, local_fll_size);
-    else
-    {
-        for ( x = 0; x < fll_entries; ++x )
-#ifdef __x86_64__
-            /* 64bit toolstack, 32bit guest.  Expand their pointers */
-            local_fll[x] = ((uint32_t*)guest_fll)[x];
-#else
-            /* 32bit toolstack, 64bit guest.  Reduce their pointers */
-            local_fll[x] = ((uint64_t*)guest_fll)[x];
-#endif
-    }
-
+    pfn_guest2local(ctx->x86_pv.width, local_fll, guest_fll, fll_entries);
 
     /* Map the guest mid p2m frames */
     guest_fl = xc_map_foreign_pages(xch, ctx->domid, PROT_READ,
@@ -142,7 +141,7 @@ static int map_p2m(struct context *ctx)
         goto err;
     }
 
-    local_fl_size = fl_entries * sizeof(unsigned long);
+    local_fl_size = fl_entries * sizeof(*local_fl);
     local_fl = malloc(local_fl_size);
     if ( !local_fl )
     {
@@ -151,20 +150,7 @@ static int map_p2m(struct context *ctx)
         goto err;
     }
 
-    if ( ctx->x86_pv.width == sizeof(unsigned long) )
-        memcpy(local_fl, guest_fl, local_fl_size);
-    else
-    {
-        for ( x = 0; x < fl_entries; ++x )
-#ifdef __x86_64__
-            /* 64bit toolstack, 32bit guest.  Expand their pointers */
-            local_fl[x] = ((uint32_t*)guest_fl)[x];
-#else
-            /* 32bit toolstack, 64bit guest.  Reduce their pointers */
-            local_fl[x] = ((uint64_t*)guest_fl)[x];
-#endif
-    }
-
+    pfn_guest2local(ctx->x86_pv.width, local_fl, guest_fl, fl_entries);
 
     /* Map the p2m leaves themselves */
     ctx->x86_pv.p2m = xc_map_foreign_pages(xch, ctx->domid, PROT_READ,
@@ -487,6 +473,7 @@ static int normalise_pagetable(struct co
 
             if ( !mfn_in_pseudophysmap(ctx, mfn) )
             {
+                /* TODO live migration */
                 ERROR("Bad MFN for L%lu[%u]",
                       type >> XEN_DOMCTL_PFINFO_LTAB_SHIFT, i);
                 pseudophysmap_walk(ctx, mfn);
