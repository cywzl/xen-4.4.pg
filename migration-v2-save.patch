# HG changeset patch
# Parent 39d678d257e102c06f2cf6c9b38482c7339f71d9

diff -r 39d678d257e1 tools/libxc/xc_domain_save2.c
--- a/tools/libxc/xc_domain_save2.c
+++ b/tools/libxc/xc_domain_save2.c
@@ -1,11 +1,78 @@
+#include <arpa/inet.h>
+#include <unistd.h>
+
+#include "xc_private.h"
+#include "xc_dom.h"
+
 #include "xg_private.h"
+#include "xg_save_restore2.h"
+
+static void construct_ihdr(struct ihdr *ihdr)
+{
+    ihdr->marker  = IHDR_MARKER;
+    ihdr->id      = htonl(IHDR_ID);
+    ihdr->version = htonl(IHDR_VERSION);
+
+    ihdr->options = htons(IHDR_OPT_LITTLE_ENDIAN);
+
+    ihdr->_res1 = ihdr->_res2 = 0;
+}
+
+static void construct_dhdr(xc_interface *xch, struct dhdr *dhdr)
+{
+    uint32_t xen_version = xc_version(xch, XENVER_version, NULL);
+
+    dhdr->type = DHDR_TYPE_x86_pv;
+    dhdr->page_shift = PAGE_SHIFT;
+    dhdr->xen_major = (xen_version >> 16) & 0xffff;
+    dhdr->xen_minor = (xen_version)       & 0xffff;
+
+    dhdr->_res1 = 0;
+}
+
+static int write_record(xc_interface *xch, int fd,
+                        uint32_t type, void *data, uint32_t size)
+{
+    static const char zeroes[8] = { 0 };
+    size_t rounded = (size + 7) & ~7UL;
+
+    if ( write_exact(fd, &type, sizeof type) ||
+         write_exact(fd, &size, sizeof size) ||
+         write_exact(fd, data, size) ||
+         write_exact(fd, zeroes, rounded - size) )
+    {
+        PERROR("Unable to write record to stream");
+        return -1;
+    }
+
+    return 0;
+}
 
 int xc_domain_save2(xc_interface *xch, int io_fd, uint32_t dom, uint32_t max_iters,
                     uint32_t max_factor, uint32_t flags,
                     struct save_callbacks* callbacks, int hvm,
                     unsigned long vm_generationid_addr)
 {
-    return 1;
+    struct ihdr ihdr;
+    struct dhdr dhdr;
+
+    IPRINTF("In %s", __func__);
+
+    construct_ihdr(&ihdr);
+    if ( write_exact(io_fd, &ihdr, sizeof ihdr) )
+    {
+        PERROR("Unable to write Image Header to stream");
+        return -1;
+    }
+
+    construct_dhdr(xch, &dhdr);
+    if ( write_exact(io_fd, &dhdr, sizeof dhdr) )
+    {
+        PERROR("Unable to write Domain Header to stream");
+        return -1;
+    }
+
+    return write_record(xch, io_fd, REC_TYPE_end, NULL, 0);
 }
 
 /*
diff -r 39d678d257e1 tools/libxc/xc_save_restore2_common.c
--- a/tools/libxc/xc_save_restore2_common.c
+++ b/tools/libxc/xc_save_restore2_common.c
@@ -1,5 +1,54 @@
 #include "xg_save_restore2.h"
 
+// TODO: Find a better place to put this...
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+
+static const char *dhdr_types[] =
+{
+    [DHDR_TYPE_x86_pv] = "x86 PV",
+    [DHDR_TYPE_x86_hvm] = "x86 HVM",
+    [DHDR_TYPE_x86_pvh] = "x86 PVH",
+    [DHDR_TYPE_arm] = "ARM",
+};
+
+const char *dhdr_type_to_str(uint32_t type)
+{
+    if ( type < ARRAY_SIZE(dhdr_types) && dhdr_types[type] )
+        return dhdr_types[type];
+
+    return "Reserved";
+}
+
+static const char *mandatory_rec_types[] =
+{
+    [REC_TYPE_end             ] = "End",
+    [REC_TYPE_page_data       ] = "Page data",
+    [REC_TYPE_vcpu_count      ] = "Vcpu count",
+    [REC_TYPE_vcpu_context    ] = "Vcpu context",
+    [REC_TYPE_vcpu_context_x1 ] = "Vcpu context 1",
+    [REC_TYPE_vcpu_context_x2 ] = "Vcpu context 2",
+    [REC_TYPE_x86_pv_info     ] = "x86 PV info",
+};
+
+/*
+static const char *optional_rec_types[] =
+{
+};
+*/
+
+const char *rec_type_to_str(uint32_t type)
+{
+    if ( type & REC_TYPE_optional )
+        return "Reserved"; /* Dont use ARRAY_SIZE() until we have some */
+
+    if ( (type & REC_TYPE_optional) == 0 &&
+         (type < ARRAY_SIZE(mandatory_rec_types)) &&
+         (mandatory_rec_types[type]) )
+        return mandatory_rec_types[type];
+
+    return "Reserved";
+}
+
 /*
  * Local variables:
  * mode: C
diff -r 39d678d257e1 tools/libxc/xg_save_restore2.h
--- a/tools/libxc/xg_save_restore2.h
+++ b/tools/libxc/xg_save_restore2.h
@@ -1,6 +1,63 @@
 #ifndef __XG_SAVE_RESTORE2__H
 #define __XG_SAVE_RESTORE2__H
 
+#include <inttypes.h>
+
+struct ihdr
+{
+    uint64_t marker;
+    uint32_t id;
+    uint32_t version;
+    uint16_t options;
+    uint16_t _res1;
+    uint32_t _res2;
+};
+
+#define IHDR_MARKER  0xffffffffffffffffULL
+#define IHDR_ID      0x58454E46U
+#define IHDR_VERSION 1
+
+#define _IHDR_OPT_ENDIAN 0
+#define IHDR_OPT_LITTLE_ENDIAN (0 << _IHDR_OPT_ENDIAN)
+#define IHDR_OPT_BIG_ENDIAN    (1 << _IHDR_OPT_ENDIAN)
+
+struct dhdr
+{
+    uint32_t type;
+    uint16_t page_shift;
+    uint16_t _res1;
+    uint32_t xen_major;
+    uint32_t xen_minor;
+};
+
+#define DHDR_TYPE_x86_pv  0x00000001U
+#define DHDR_TYPE_x86_hvm 0x00000002U
+#define DHDR_TYPE_x86_pvh 0x00000003U
+#define DHDR_TYPE_arm     0x00000004U
+
+const char *dhdr_type_to_str(uint32_t type);
+
+struct rhdr
+{
+    uint32_t type;
+    uint32_t length;
+};
+
+/* Somewhat arbitrary - 8MB */
+#define REC_LENGTH_MAX           (8U << 20)
+
+#define REC_TYPE_end             0x00000000U
+#define REC_TYPE_page_data       0x00000001U
+#define REC_TYPE_vcpu_count      0x00000002U
+#define REC_TYPE_vcpu_context    0x00000003U
+#define REC_TYPE_vcpu_context_x1 0x00000004U
+#define REC_TYPE_vcpu_context_x2 0x00000005U
+#define REC_TYPE_x86_pv_info     0x00000006U
+
+#define REC_TYPE_optional        0x80000000U
+
+const char *rec_type_to_str(uint32_t type);
+
 #endif
 /*
  * Local variables:
