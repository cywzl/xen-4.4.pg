Support batch saving image pages.

Batch multiple page read.
Actually limited to one page to be able to test restore.

diff -r f1edc8f21864 tools/libxc/saverestore/save_x86_pv.c
--- a/tools/libxc/saverestore/save_x86_pv.c	Fri Apr 04 16:54:23 2014 +0100
+++ b/tools/libxc/saverestore/save_x86_pv.c	Mon Apr 07 10:05:19 2014 +0100
@@ -519,26 +519,28 @@ static int normalise_pagetable(struct co
 
 static int write_all_memory(struct context *ctx)
 {
+    enum { max_batch = 1 };
     xc_interface *xch = ctx->xch;
-    xen_pfn_t x = 0, mfn, type;
-    int rc = -1, err;
+    xen_pfn_t x = 0, mfns[max_batch], pfn_types[max_batch];
+    int rc = -1, pfn_errs[max_batch];
     void *guest_page = NULL;
     void *local_page = malloc(PAGE_SIZE);
+    unsigned int batch = 0;
 
     struct
     {
         struct rec_page_data_header h;
-        uint64_t pfn;
-    } page_data = { { 1, 0 } , 0 };
+        uint64_t pfns[max_batch];
+    } page_data = { { 1, 0 } , { 0 } };
 
     struct record rec =
     {
         .type = REC_TYPE_page_data,
-        .length = sizeof page_data,
+        .length = 16,
         .data = &page_data,
     };
 
-    XC_BUILD_BUG_ON(sizeof page_data != 16);
+    XC_BUILD_BUG_ON(sizeof(page_data) != 8 + sizeof(uint64_t) * max_batch);
 
     if ( !local_page )
     {
@@ -546,73 +548,101 @@ static int write_all_memory(struct conte
         goto err;
     }
 
-    for ( x = 0; x <= ctx->x86_pv.max_pfn; ++x )
+    for ( x = 0; x <= ctx->x86_pv.max_pfn; )
     {
-        type = mfn = pfn_to_mfn(ctx, x);
+        unsigned int j;
+        uint32_t rec_length;
+
+        batch = MIN(ctx->x86_pv.max_pfn - x, max_batch - 1) + 1;
+        page_data.h.count = batch;
+
+        for ( j = 0; j < batch; ++j )
+            pfn_types[j] = mfns[j] = pfn_to_mfn(ctx, x + j);
 
         guest_page = xc_map_foreign_bulk(
-            xch, ctx->domid, PROT_READ, &mfn, &err, 1);
+            xch, ctx->domid, PROT_READ, mfns, pfn_errs, batch);
         if ( !guest_page )
         {
-            PERROR("Unable to map mfn %#lx (err %d)", mfn, err);
+            PERROR("Unable to map mfns from %#lx (err %d) type %lx ptr %p", mfns[0], pfn_errs[0], pfn_types[0], guest_page);
             goto err;
         }
 
-        if ( xc_get_pfn_type_batch(xch, ctx->domid, 1, &type) )
+        if ( xc_get_pfn_type_batch(xch, ctx->domid, batch, pfn_types) )
         {
-            PERROR("Unable to get mfn %#lx type", mfn);
+            PERROR("Unable to get mfn %#lx type", mfns[0]);
             goto err;
         }
 
-        /* Write a record */
-#ifdef __x86_64__
-        page_data.pfn = (type << 32) | x;
-#else
-        page_data.pfn = (((uint64_t)type) << 32) | x;
-#endif
+        /* Initialize PFNs and compute total record length */
+        rec_length = 8 + batch * sizeof(uint64_t);
+        for ( j = 0; j < batch; ++j )
+        {
+            page_data.pfns[j] = (((uint64_t)pfn_types[j]) << 32) | (x + j);
 
-        switch (type)
+            switch (pfn_types[j])
+            {
+            case XEN_DOMCTL_PFINFO_BROKEN:
+            case XEN_DOMCTL_PFINFO_XALLOC:
+            case XEN_DOMCTL_PFINFO_XTAB:
+                break;
+            default:
+                rec_length += PAGE_SIZE;
+                break;
+            }
+        }
+
+        /* Write header and page PFNs */
+        rec.length = rec_length;
+        if ( write_exact(ctx->fd, &rec, sizeof(rec.type) + sizeof(rec.length)) ||
+             write_exact(ctx->fd, &page_data, 8 + batch * sizeof(uint64_t)) )
+            goto err;
+
+        /* Write pages */
+        for ( j = 0; j < batch; ++j )
         {
-        case XEN_DOMCTL_PFINFO_BROKEN:
-        case XEN_DOMCTL_PFINFO_XALLOC:
-        case XEN_DOMCTL_PFINFO_XTAB:
-            if ( write_record(ctx, &rec) )
-                goto err;
-            break;
+            switch (pfn_types[j])
+            {
+            case XEN_DOMCTL_PFINFO_BROKEN:
+            case XEN_DOMCTL_PFINFO_XALLOC:
+            case XEN_DOMCTL_PFINFO_XTAB:
+                break;
 
-        case XEN_DOMCTL_PFINFO_L1TAB:
-        case XEN_DOMCTL_PFINFO_L1TAB | XEN_DOMCTL_PFINFO_LPINTAB:
-        case XEN_DOMCTL_PFINFO_L2TAB:
-        case XEN_DOMCTL_PFINFO_L2TAB | XEN_DOMCTL_PFINFO_LPINTAB:
-        case XEN_DOMCTL_PFINFO_L3TAB:
-        case XEN_DOMCTL_PFINFO_L3TAB | XEN_DOMCTL_PFINFO_LPINTAB:
-        case XEN_DOMCTL_PFINFO_L4TAB:
-        case XEN_DOMCTL_PFINFO_L4TAB | XEN_DOMCTL_PFINFO_LPINTAB:
-            if ( err ) {
-                ERROR("Invalid pfn %#lx mfn %#lx type %#lx", x, mfn, type);
+            case XEN_DOMCTL_PFINFO_L1TAB:
+            case XEN_DOMCTL_PFINFO_L1TAB | XEN_DOMCTL_PFINFO_LPINTAB:
+            case XEN_DOMCTL_PFINFO_L2TAB:
+            case XEN_DOMCTL_PFINFO_L2TAB | XEN_DOMCTL_PFINFO_LPINTAB:
+            case XEN_DOMCTL_PFINFO_L3TAB:
+            case XEN_DOMCTL_PFINFO_L3TAB | XEN_DOMCTL_PFINFO_LPINTAB:
+            case XEN_DOMCTL_PFINFO_L4TAB:
+            case XEN_DOMCTL_PFINFO_L4TAB | XEN_DOMCTL_PFINFO_LPINTAB:
+                if ( pfn_errs[j] ) {
+                    ERROR("Invalid pfn %#lx mfn %#lx type %#lx", x + j, mfns[j], pfn_types[j]);
+                    goto err;
+                }
+                if ( normalise_pagetable(ctx, guest_page + PAGE_SIZE * j, local_page, pfn_types[j]) ||
+                     write_exact(ctx->fd, local_page, PAGE_SIZE) )
+                    goto err;
+                break;
+
+            case XEN_DOMCTL_PFINFO_NOTAB:
+                if ( pfn_errs[j] ) {
+                    ERROR("Invalid pfn %#lx mfn %#lx type %#lx", x + j, mfns[j], pfn_types[j]);
+                    goto err;
+                }
+                if ( write_exact(ctx->fd, guest_page + PAGE_SIZE * j, PAGE_SIZE) )
+                    goto err;
+                break;
+
+            default:
+                ERROR("Bad mfn %#lx, type %#lx", mfns[j], pfn_types[j]);
                 goto err;
             }
-            if ( normalise_pagetable(ctx, guest_page, local_page, type) ||
-                 write_split_record(ctx, &rec, local_page, PAGE_SIZE) )
-                goto err;
-            break;
-
-        case XEN_DOMCTL_PFINFO_NOTAB:
-            if ( err ) {
-                ERROR("Invalid pfn %#lx mfn %#lx type %#lx", x, mfn, type);
-                goto err;
-            }
-            if ( write_split_record(ctx, &rec, guest_page, PAGE_SIZE) )
-                goto err;
-            break;
-
-        default:
-            IPRINTF("Bad mfn %#lx, type %#lx", mfn, type);
-            goto err;
         }
 
-        munmap(guest_page, PAGE_SIZE);
+        munmap(guest_page, batch * PAGE_SIZE);
         guest_page = NULL;
+
+        x += batch;
     }
 
 
@@ -621,7 +651,7 @@ static int write_all_memory(struct conte
 
  err:
     if ( guest_page )
-        munmap(guest_page, PAGE_SIZE);
+        munmap(guest_page, batch * PAGE_SIZE);
     free(local_page);
 
     return rc;
