From ddb31e0daeb3cb0ffed7827323525b7aa2d94c41 Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Thu, 6 Mar 2014 00:03:18 +0000
Subject: [PATCH] Stream validation

---
 tools/migrationv2/generate.py   |   33 ++++++++
 tools/migrationv2/streamspec.py |   48 +++++++++++
 tools/migrationv2/verify.py     |  175 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 256 insertions(+)
 create mode 100755 tools/migrationv2/generate.py
 create mode 100644 tools/migrationv2/streamspec.py
 create mode 100755 tools/migrationv2/verify.py

diff --git a/tools/migrationv2/generate.py b/tools/migrationv2/generate.py
new file mode 100755
index 0000000..bfc9503
--- /dev/null
+++ b/tools/migrationv2/generate.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from streamspec import *
+import struct, sys
+
+ihdr = struct.pack(IHDR_FORMAT,
+                   0xffffffffffffffff, # Marker
+                   IHDR_IDENT,         # "XENF" in ASCII
+                   1,                  # Version
+                   IHDR_OPT_LE,        # Options
+                   0, 0                # Reserved
+                   )
+
+dhdr = struct.pack(DHDR_FORMAT,
+                   1,  # Type (x86 pv)
+                   12, # Page size
+                   0,  # Reserved
+                   4,  # Xen major
+                   5   # Xen minor
+                   )
+
+def emit_record(type, len):
+    r = struct.pack(RH_FORMAT, type, len)
+
+    len = (len + 7) & ~7
+    r += '\x00' * len
+
+    sys.stdout.write(r)
+
+sys.stdout.write(ihdr)
+sys.stdout.write(dhdr)
+emit_record(REC_TYPE_end, 0)
diff --git a/tools/migrationv2/streamspec.py b/tools/migrationv2/streamspec.py
new file mode 100644
index 0000000..b0e1d98
--- /dev/null
+++ b/tools/migrationv2/streamspec.py
@@ -0,0 +1,48 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+# Image Header
+IHDR_FORMAT = "!QIIHHI"
+
+IHDR_IDENT = 0x58454E46 # "XENF" in ASCII
+
+IHDR_OPT_ENDIAN_ = 0
+IHDR_OPT_LE = (0 << IHDR_OPT_ENDIAN_)
+IHDR_OPT_BE = (1 << IHDR_OPT_ENDIAN_)
+
+IHDR_OPT_RESZ_MASK = 0xfffe
+
+# Domain Header
+DHDR_FORMAT = "=IHHII"
+
+DHDR_TYPE_x86_pv  = 0x00000001
+DHDR_TYPE_x86_hvm = 0x00000002
+DHDR_TYPE_x86_pvh = 0x00000003
+DHDR_TYPE_arm     = 0x00000004
+
+dhdr_type_to_str = {
+    DHDR_TYPE_x86_pv  : "x86 PV",
+    DHDR_TYPE_x86_hvm : "x86 HVM",
+    DHDR_TYPE_x86_pvh : "x86 PVH",
+    DHDR_TYPE_arm     : "ARM",
+}
+
+RH_FORMAT = "=II"
+
+REC_TYPE_end             = 0x00000000
+REC_TYPE_page_data       = 0x00000001
+REC_TYPE_vcpu_count      = 0x00000002
+REC_TYPE_vcpu_context    = 0x00000003
+REC_TYPE_vcpu_context_x1 = 0x00000004
+REC_TYPE_vcpu_context_x2 = 0x00000005
+REC_TYPE_x86_pv_info     = 0x00000006
+
+rec_type_to_str = {
+    REC_TYPE_end             : "End",
+    REC_TYPE_page_data       : "Page data",
+    REC_TYPE_vcpu_count      : "Vcpu count",
+    REC_TYPE_vcpu_context    : "Vcpu context",
+    REC_TYPE_vcpu_context_x1 : "Vcpu context 1",
+    REC_TYPE_vcpu_context_x2 : "Vcpu context 2",
+    REC_TYPE_x86_pv_info     : "x86 PV info",
+}
diff --git a/tools/migrationv2/verify.py b/tools/migrationv2/verify.py
new file mode 100755
index 0000000..7e51ca0
--- /dev/null
+++ b/tools/migrationv2/verify.py
@@ -0,0 +1,175 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import sys
+import struct
+
+from streamspec import *
+
+class StreamError(StandardError):
+    pass
+
+class RecordError(StandardError):
+    pass
+
+def skip_xl_header(stream):
+
+    magic = stream.read(8)
+    if magic != "mat\n \0 \r":
+        return False
+
+    header = stream.read(16)
+    if len(header) != 16:
+        return False
+
+    _, _, _, optlen = struct.unpack("=IIII", header)
+
+    optdata = stream.read(optlen)
+    if len(optdata) != optlen:
+        return False
+
+    return True
+
+
+def verify_ihdr(stream):
+    """ Verify an image header """
+
+    datasz = struct.calcsize(IHDR_FORMAT)
+    data = stream.read(datasz)
+
+    # xl header record?
+    if data == "Xen saved domain, xl for":
+        if skip_xl_header(stream):
+            data = stream.read(datasz)
+        else:
+            raise StreamError("Invalid looking xl header on the stream")
+
+    if len(data) != datasz:
+        raise IOError("Truncated stream")
+
+    marker, id, version, options, res1, res2 = struct.unpack(IHDR_FORMAT, data)
+
+    if marker != 0xffffffffffffffff:
+        raise StreamError("Bad image marker: Expected 0xffffffffffffffff, got 0x%x" % (marker, ))
+
+    if id != 0x58454e46:
+        raise StreamError("Bad image id: Expected 0x0x58454e46, got 0x%x" % (id, ))
+
+    if version != 1:
+        raise StreamError("Unknown image version: Expected 1, got %d" % (version, ))
+
+    if options & IHDR_OPT_RESZ_MASK:
+        raise StreamError("Reserved bits set in image options field: 0x%x" % (options & IHDR_OPT_RESZ_MASK))
+
+    if res1 != 0 or res2 != 0:
+        raise StreamError("Reserved bits set in image header: 0x%04x:0x%08x" % (res1, res2))
+
+    if ( sys.byteorder == "little" and
+         (options & IHDR_OPT_ENDIAN_) != IHDR_OPT_LE ):
+        raise StreamError("Stream is not native endianess - unable to validate")
+
+    print "Valid Image Header:",
+    if options & IHDR_OPT_BE:
+        print "big endian"
+    else:
+        print "little endian"
+
+def verify_dhdr(stream):
+    """ Verify a domain header """
+
+    datasz = struct.calcsize(DHDR_FORMAT)
+    data = stream.read(datasz)
+
+    if len(data) != datasz:
+        raise IOError("Truncated stream")
+
+    type, page_shift, res1, major, minor = struct.unpack(DHDR_FORMAT, data)
+
+    if type not in dhdr_type_to_str:
+        raise StreamError("Unrecognised domain type 0x%x" % (type, ))
+
+    if res1 != 0:
+        raise StreamError("Reserved bits set in domain header 0x%04x" % (res1, ))
+
+    if page_shift != 12:
+        raise StreamError("Page shift expected to be 12.  Got %d" % (page_shift, ))
+
+    print "Valid Domain Header: %s from Xen %d.%d (page sz %d)" \
+        % (dhdr_type_to_str[type], major, minor, 2**page_shift)
+
+
+def verify_record_end(content):
+
+    if len(content) != 0:
+        raise RecordError("End record with non-zero length")
+
+record_verifiers = {
+    REC_TYPE_end : verify_record_end,
+}
+
+def verify_record(stream):
+    """ Verify a record """
+
+    datasz = struct.calcsize(RH_FORMAT)
+    data = stream.read(datasz)
+
+    if len(data) != datasz:
+        raise IOError("Truncated stream")
+
+    type, length = struct.unpack(RH_FORMAT, data)
+
+    if type not in rec_type_to_str:
+        raise StreamError("Unrecognised record type %x" % (type, ))
+
+    contentsz = (length + 7) & ~7
+    content = stream.read(contentsz)
+
+    if len(content) != contentsz:
+        raise IOError("Truncated stream")
+
+    padding = content[length:]
+    if padding != "\x00" * len(padding):
+        raise StreamError("Nonzero padding found on record")
+
+    print "Valid Record Header: %s, length %d" % (rec_type_to_str[type], length)
+
+    if type not in record_verifiers:
+        raise RuntimeError("No verification function")
+    else:
+        record_verifiers[type](content[:length])
+
+    return type
+
+
+def main(argv = sys.argv):
+
+    if len(argv) == 2:
+        fin = open(argv[1], "rb")
+    else:
+        fin = sys.stdin
+
+    try:
+        verify_ihdr(fin)
+        verify_dhdr(fin)
+
+        while verify_record(fin) != REC_TYPE_end:
+            pass
+
+        if fin.read(1) != "":
+            raise StreamError("Junk found on the end of the stream")
+
+    except (IOError, StreamError, RecordError) as e:
+        print "Error: ", e
+        return 1
+
+    except RuntimeError as e:
+        print "Script error", e
+        print "Please fix me"
+        return 2
+
+    print "Done"
+    return 0
+
+
+if __name__ == "__main__":
+    sys.exit(main(sys.argv))
-- 
1.7.10.4

