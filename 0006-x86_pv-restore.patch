From 77aa84d25e369973c6306f8dd1f6255b3165eef2 Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Sun, 16 Mar 2014 02:09:17 +0000
Subject: [PATCH 6/6] x86_pv restore

---
 tools/libxc/saverestore/common.c         |   51 ++++++++
 tools/libxc/saverestore/common.h         |   16 +++
 tools/libxc/saverestore/restore.c        |   90 +++++++++++++-
 tools/libxc/saverestore/restore_x86_pv.c |  193 ++++++++++++++++++++++++++++++
 4 files changed, 349 insertions(+), 1 deletion(-)
 create mode 100644 tools/libxc/saverestore/restore_x86_pv.c

diff --git a/tools/libxc/saverestore/common.c b/tools/libxc/saverestore/common.c
index 2b70bfe..a28596f 100644
--- a/tools/libxc/saverestore/common.c
+++ b/tools/libxc/saverestore/common.c
@@ -77,6 +77,57 @@ int write_record(struct context *ctx, struct record *rec)
     return 0;
 }
 
+int read_record(struct context *ctx, struct record *rec)
+{
+    xc_interface *xch = ctx->xch;
+    struct rhdr rhdr;
+    size_t datasz;
+
+    if ( read_exact(ctx->fd, &rhdr, sizeof rhdr) )
+    {
+        PERROR("Failed to read Record Header from stream");
+        return -1;
+    }
+    else if ( rhdr.length > REC_LENGTH_MAX )
+    {
+        ERROR("Record (0x%08"PRIx32", %s) length 0x%"PRIx32
+              " exceeds max (0x%"PRIx32")",
+              rhdr.type, rec_type_to_str(rhdr.type),
+              rhdr.length, REC_LENGTH_MAX);
+        return -1;
+    }
+
+    datasz = (rhdr.length + 7) & ~7U;
+
+    if ( datasz )
+    {
+        rec->data = malloc(datasz);
+
+        if ( !rec->data )
+        {
+            ERROR("Unable to allocate %zu bytes for record data (0x%08"PRIx32", %s)",
+                  datasz, rhdr.type, rec_type_to_str(rhdr.type));
+            return -1;
+        }
+
+        if ( read_exact(ctx->fd, rec->data, datasz) )
+        {
+            free(rec->data);
+            rec->data = NULL;
+            PERROR("Failed to read %zu bytes of data for record (0x%08"PRIx32", %s)",
+                   datasz, rhdr.type, rec_type_to_str(rhdr.type));
+            return -1;
+        }
+    }
+    else
+        rec->data = NULL;
+
+    rec->type   = rhdr.type;
+    rec->length = rhdr.length;
+
+    return 0;
+};
+
 /*
  * Local variables:
  * mode: C
diff --git a/tools/libxc/saverestore/common.h b/tools/libxc/saverestore/common.h
index 36c7b87..79cbd94 100644
--- a/tools/libxc/saverestore/common.h
+++ b/tools/libxc/saverestore/common.h
@@ -79,6 +79,8 @@ struct context
 
 /* Saves an x86 PV domain. */
 int save_x86_pv(struct context *ctx);
+/* Restores an x86 PV domain. */
+int restore_x86_pv(struct context *ctx);
 
 struct record
 {
@@ -103,6 +105,20 @@ struct record
  */
 int write_record(struct context *ctx, struct record *rec);
 
+/*
+ * Reads a record from the stream, and fills in the record structure.
+ *
+ * Returns 0 on success and non-0 on failure.
+ *
+ * On success, the records type and size shall be valid.
+ * - If size is 0, data shall be NULL.
+ * - If size is non-0, data shall be a buffer allocated by malloc() which must
+ *   be passed to free() by the caller.
+ *
+ * On failure, the contents of the record structure are undefined.
+ */
+int read_record(struct context *ctx, struct record *rec);
+
 #endif
 /*
  * Local variables:
diff --git a/tools/libxc/saverestore/restore.c b/tools/libxc/saverestore/restore.c
index 6624baa..5f6dcbe 100644
--- a/tools/libxc/saverestore/restore.c
+++ b/tools/libxc/saverestore/restore.c
@@ -1,5 +1,62 @@
+#include <arpa/inet.h>
+
 #include "common.h"
 
+static int read_headers(struct context *ctx)
+{
+    xc_interface *xch = ctx->xch;
+    struct ihdr ihdr;
+    struct dhdr dhdr;
+
+    if ( read_exact(ctx->fd, &ihdr, sizeof ihdr) )
+    {
+        PERROR("Failed to read Image Header from stream");
+        return -1;
+    }
+
+    ihdr.id      = ntohl(ihdr.id);
+    ihdr.version = ntohl(ihdr.version);
+    ihdr.options = ntohs(ihdr.options);
+
+    if ( ihdr.marker != IHDR_MARKER )
+    {
+        ERROR("Invalid marker: Got 0x%016"PRIx64, ihdr.marker);
+        return -1;
+    }
+    else if ( ihdr.id != IHDR_ID )
+    {
+        ERROR("Invalid ID: Expected 0x%08"PRIx32", Got 0x%08"PRIx32,
+              IHDR_ID, ihdr.id);
+        return -1;
+    }
+    else if ( ihdr.version != IHDR_VERSION )
+    {
+        ERROR("Invalid Version: Expected %d, Got %d", ihdr.version, IHDR_VERSION);
+        return -1;
+    }
+    else if ( ihdr.options & IHDR_OPT_LITTLE_ENDIAN )
+    {
+        ERROR("Unable to handle big endian streams");
+        return -1;
+    }
+
+    ctx->restore.format_version = ihdr.version;
+
+    if ( read_exact(ctx->fd, &dhdr, sizeof dhdr) )
+    {
+        PERROR("Failed to read Domain Header from stream");
+        return -1;
+    }
+
+    ctx->restore.guest_type = dhdr.type;
+    ctx->restore.guest_page_size = (1U << dhdr.page_shift);
+
+    IPRINTF("Found %s domain from Xen %d.%d",
+            dhdr_type_to_str(dhdr.type), dhdr.xen_major, dhdr.xen_minor);
+    return 0;
+}
+
+
 int xc_domain_restore2(xc_interface *xch, int io_fd, uint32_t dom,
                        unsigned int store_evtchn, unsigned long *store_mfn,
                        domid_t store_domid, unsigned int console_evtchn,
@@ -8,8 +65,39 @@ int xc_domain_restore2(xc_interface *xch, int io_fd, uint32_t dom,
                        int checkpointed_stream,
                        struct restore_callbacks *callbacks)
 {
+    struct context ctx =
+        {
+            .xch = xch,
+            .fd = io_fd,
+        };
+
     IPRINTF("In experimental %s", __func__);
-    return -1;
+
+    if ( xc_domain_getinfo(xch, dom, 1, &ctx.dominfo) != 1 )
+    {
+        PERROR("Failed to get domain info");
+        return -1;
+    }
+
+    if ( ctx.dominfo.domid != dom )
+    {
+        ERROR("Domain %d does not exist", dom);
+        return -1;
+    }
+
+    ctx.domid = dom;
+    IPRINTF("Restoring domain %d", dom);
+
+    if ( read_headers(&ctx) )
+        return -1;
+
+    if ( ctx.dominfo.hvm )
+    {
+        ERROR("HVM Restore not supported yet");
+        return -1;
+    }
+    else
+        return restore_x86_pv(&ctx);
 }
 
 /*
diff --git a/tools/libxc/saverestore/restore_x86_pv.c b/tools/libxc/saverestore/restore_x86_pv.c
new file mode 100644
index 0000000..594b5c7
--- /dev/null
+++ b/tools/libxc/saverestore/restore_x86_pv.c
@@ -0,0 +1,193 @@
+#include <assert.h>
+#include <arpa/inet.h>
+
+#include "common_x86_pv.h"
+
+static int handle_end(struct context *ctx, struct record *rec)
+{
+    xc_interface *xch = ctx->xch;
+
+    DPRINTF("End record");
+    return 0;
+}
+
+static int handle_x86_pv_info(struct context *ctx, struct record *rec)
+{
+    xc_interface *xch = ctx->xch;
+    struct x86_pv_info *info = rec->data;
+
+    if ( info->guest_width != 4 &&
+         info->guest_width != 8 )
+    {
+        ERROR("Unexpected guest width %"PRIu32", Expected 4 or 8",
+              info->guest_width);
+        return -1;
+    }
+
+    if ( info->guest_width != ctx->x86_pv.width )
+    {
+        ERROR("Width of guest in stream (%"PRIu32
+              " bits) differs with existing domain (%"PRIu32" bits)",
+              info->guest_width * 8, ctx->x86_pv.width * 8);
+        return -1;
+    }
+
+    if ( info->pt_levels != 3 &&
+         info->pt_levels != 4 )
+    {
+        ERROR("Unexpected guest levels %"PRIu32", Expected 3 or 4",
+              info->pt_levels);
+        return -1;
+    }
+
+    if ( info->pt_levels != ctx->x86_pv.levels )
+    {
+        ERROR("Levels of guest in stream (%"PRIu32
+              ") differs with existing domain (%"PRIu32")",
+              info->pt_levels, ctx->x86_pv.levels);
+        return -1;
+    }
+
+
+    DPRINTF("X86_PV_INFO record: %d bits, %d levels",
+            ctx->x86_pv.width * 8, ctx->x86_pv.levels);
+    return 0;
+}
+
+static int handle_x86_pv_p2m_frames(struct context *ctx, struct record *rec)
+{
+    xc_interface *xch = ctx->xch;
+    struct x86_pv_p2m_frames *data = rec->data;
+    unsigned start, end, x;
+
+    if ( !ctx->x86_pv.p2m_pfns )
+    {
+        ctx->x86_pv.p2m_pfns = malloc(ctx->x86_pv.p2m_frames * sizeof(xen_pfn_t));
+        if ( !ctx->x86_pv.p2m_pfns )
+        {
+            ERROR("Cannot allocate %zu bytes for p2m pfns list",
+                  ctx->x86_pv.p2m_frames * sizeof(xen_pfn_t));
+            return -1;
+        }
+    }
+
+    if ( data->end_gfn > ctx->x86_pv.max_gfn )
+    {
+        ERROR("End gfn in stream (%#"PRIx32") exceeds domain max (%#lx)",
+              data->end_gfn, ctx->x86_pv.max_gfn);
+        return -1;
+    }
+    else if ( data->start_gfn > data->end_gfn )
+    {
+        ERROR("End gfn in stream (%#"PRIx32") exceeds Start (%#"PRIx32")",
+              data->end_gfn, data->start_gfn);
+        return -1;
+    }
+
+    start = data->start_gfn / ctx->x86_pv.fpp;
+    end = (data->end_gfn + ctx->x86_pv.fpp) / ctx->x86_pv.fpp;
+
+    for ( x = 0; x < (end - start); ++x )
+        ctx->x86_pv.p2m_pfns[start + x] = data->p2m_gfns[x];
+
+    DPRINTF("X86_PV_P2M_FRAMES record: GFNs %#"PRIx32"->%#"PRIx32,
+            data->start_gfn, data->end_gfn);
+
+    return 0;
+}
+
+int restore_x86_pv(struct context *ctx)
+{
+    xc_interface *xch = ctx->xch;
+    struct record rec;
+    int rc;
+
+    IPRINTF("In experimental %s", __func__);
+
+    if ( ctx->restore.guest_type != DHDR_TYPE_x86_pv )
+    {
+        ERROR("Unable to restore %s domain into an x86_pv domain",
+              dhdr_type_to_str(ctx->restore.guest_type));
+        return -1;
+    }
+    else if ( ctx->restore.guest_page_size != 4096 )
+    {
+        ERROR("Invalid page size %d for x86_pv domains",
+              ctx->restore.guest_page_size);
+        return -1;
+    }
+
+    rc = x86_pv_domain_info(ctx);
+    if ( rc )
+        goto err;
+
+    rc = x86_pv_map_m2p(ctx);
+    if ( rc )
+        goto err;
+
+    do
+    {
+        rc = read_record(ctx, &rec);
+        if ( rc )
+            goto err;
+
+        switch ( rec.type )
+        {
+        case REC_TYPE_end:
+            rc = handle_end(ctx, &rec);
+            break;
+
+        case REC_TYPE_x86_pv_info:
+            rc = handle_x86_pv_info(ctx, &rec);
+            break;
+
+        case REC_TYPE_x86_pv_p2m_frames:
+            rc = handle_x86_pv_p2m_frames(ctx, &rec);
+            break;
+
+        default:
+            if ( rec.type & REC_TYPE_optional )
+            {
+                IPRINTF("Ignoring optional record (0x%"PRIx32", %s)",
+                        rec.type, rec_type_to_str(rec.type));
+                rc = 0;
+                break;
+            }
+
+            ERROR("Invalid record type (0x%"PRIx32", %s) for x86_pv domains",
+                  rec.type, rec_type_to_str(rec.type));
+            rc = -1;
+            break;
+        }
+
+        free(rec.data);
+        if ( rc )
+            goto err;
+
+    } while ( rec.type != REC_TYPE_end );
+
+    /* all done */
+    assert(!rc);
+    goto cleanup;
+
+ err:
+    assert(rc);
+ cleanup:
+
+    free(ctx->x86_pv.p2m_pfns);
+
+    if ( ctx->x86_pv.m2p )
+        munmap(ctx->x86_pv.m2p, ctx->x86_pv.nr_m2p_frames * PAGE_SIZE);
+
+    return rc;
+}
+
+/*
+ * Local variables:
+ * mode: C
+ * c-file-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
-- 
1.7.10.4

