# HG changeset patch
# Parent a2929faf190801c3141dd0a46cacddcc949a2df3

diff -r a2929faf1908 xen/arch/x86/msi.c
--- a/xen/arch/x86/msi.c
+++ b/xen/arch/x86/msi.c
@@ -1201,78 +1201,89 @@ void __init early_msi_init(void)
         BUG();
 }
 
-static void dump_msi(unsigned char key)
+/*
+ * Dump MSI information for a specific irq.  The use_locks parameter should
+ * only be false for custom debugging when the lock state might not be
+ * consistent (e.g. on crash).
+ */
+static void __dump_msi(int irq, bool_t use_locks)
+{
+    struct irq_desc *desc = irq_to_desc(irq);
+    const struct msi_desc *entry;
+    u32 addr, data, dest32;
+    signed char mask;
+    struct msi_attrib attr;
+    unsigned long flags = 0;
+    const char *type = "???";
+
+    if ( !irq_desc_initialized(desc) )
+        return;
+
+    if ( use_locks )
+        spin_lock_irqsave(&desc->lock, flags);
+
+    entry = desc->msi_desc;
+    if ( !entry )
+    {
+        if ( use_locks )
+            spin_unlock_irqrestore(&desc->lock, flags);
+        return;
+    }
+
+    switch ( entry->msi_attrib.type )
+    {
+    case PCI_CAP_ID_MSI: type = "MSI"; break;
+    case PCI_CAP_ID_MSIX: type = "MSI-X"; break;
+    case 0:
+        switch ( entry->msi_attrib.pos )
+        {
+        case MSI_TYPE_HPET: type = "HPET"; break;
+        case MSI_TYPE_IOMMU: type = "IOMMU"; break;
+        }
+        break;
+    }
+
+    data = entry->msg.data;
+    addr = entry->msg.address_lo;
+    dest32 = entry->msg.dest32;
+    attr = entry->msi_attrib;
+    if ( entry->msi_attrib.type )
+        mask = msi_get_mask_bit(entry);
+    else
+        mask = -1;
+
+    if ( use_locks )
+        spin_unlock_irqrestore(&desc->lock, flags);
+
+    if ( mask >= 0 )
+        mask += '0';
+    else
+        mask = '?';
+    printk(" %-6s%4u vec=%02x%7s%6s%3sassert%5s%7s"
+           " dest=%08x mask=%d/%d/%c\n",
+           type, irq,
+           (data & MSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT,
+           data & MSI_DATA_DELIVERY_LOWPRI ? "lowest" : "fixed",
+           data & MSI_DATA_TRIGGER_LEVEL ? "level" : "edge",
+           data & MSI_DATA_LEVEL_ASSERT ? "" : "de",
+           addr & MSI_ADDR_DESTMODE_LOGIC ? "log" : "phys",
+           addr & MSI_ADDR_REDIRECTION_LOWPRI ? "lowest" : "cpu",
+           dest32, attr.maskbit, attr.masked, mask);
+}
+
+static void dump_msis(unsigned char key)
 {
     unsigned int irq;
 
     printk("MSI information:\n");
 
     for ( irq = 0; irq < nr_irqs; irq++ )
-    {
-        struct irq_desc *desc = irq_to_desc(irq);
-        const struct msi_desc *entry;
-        u32 addr, data, dest32;
-        signed char mask;
-        struct msi_attrib attr;
-        unsigned long flags;
-        const char *type = "???";
-
-        if ( !irq_desc_initialized(desc) )
-            continue;
-
-        spin_lock_irqsave(&desc->lock, flags);
-
-        entry = desc->msi_desc;
-        if ( !entry )
-        {
-            spin_unlock_irqrestore(&desc->lock, flags);
-            continue;
-        }
-
-        switch ( entry->msi_attrib.type )
-        {
-        case PCI_CAP_ID_MSI: type = "MSI"; break;
-        case PCI_CAP_ID_MSIX: type = "MSI-X"; break;
-        case 0:
-            switch ( entry->msi_attrib.pos )
-            {
-            case MSI_TYPE_HPET: type = "HPET"; break;
-            case MSI_TYPE_IOMMU: type = "IOMMU"; break;
-            }
-            break;
-        }
-
-        data = entry->msg.data;
-        addr = entry->msg.address_lo;
-        dest32 = entry->msg.dest32;
-        attr = entry->msi_attrib;
-        if ( entry->msi_attrib.type )
-            mask = msi_get_mask_bit(entry);
-        else
-            mask = -1;
-
-        spin_unlock_irqrestore(&desc->lock, flags);
-
-        if ( mask >= 0 )
-            mask += '0';
-        else
-            mask = '?';
-        printk(" %-6s%4u vec=%02x%7s%6s%3sassert%5s%7s"
-               " dest=%08x mask=%d/%d/%c\n",
-               type, irq,
-               (data & MSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT,
-               data & MSI_DATA_DELIVERY_LOWPRI ? "lowest" : "fixed",
-               data & MSI_DATA_TRIGGER_LEVEL ? "level" : "edge",
-               data & MSI_DATA_LEVEL_ASSERT ? "" : "de",
-               addr & MSI_ADDR_DESTMODE_LOGIC ? "log" : "phys",
-               addr & MSI_ADDR_REDIRECTION_LOWPRI ? "lowest" : "cpu",
-               dest32, attr.maskbit, attr.masked, mask);
-    }
+        __dump_msi(irq, 1);
 }
 
 static struct keyhandler dump_msi_keyhandler = {
     .diagnostic = 1,
-    .u.fn = dump_msi,
+    .u.fn = dump_msis,
     .desc = "dump MSI state"
 };
 
