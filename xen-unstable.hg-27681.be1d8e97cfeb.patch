# HG changeset patch
# User Jan Beulich <jbeulich@suse.com>
# Date 1380547692 -7200
# Node ID be1d8e97cfeb163e1fa6a1880d46852122423a03
# Parent  dd9677a90f3d0a3592e45b74489da261a33b0d34
x86: don't blindly create L3 tables for the direct map

Now that the direct map area can extend all the way up to almost the
end of address space, this is wasteful.

Also fold two almost redundant messages in SRAT parsing into one.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Tested-by: Malcolm Crossley <malcolm.crossley@citrix.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
Acked-by: Keir Fraser <keir@xen.org>

diff -r dd9677a90f3d -r be1d8e97cfeb xen/arch/x86/mm.c
--- a/xen/arch/x86/mm.c
+++ b/xen/arch/x86/mm.c
@@ -137,7 +137,7 @@ l1_pgentry_t __attribute__ ((__section__
 #define PTE_UPDATE_WITH_CMPXCHG
 #endif
 
-bool_t __read_mostly mem_hotplug = 0;
+paddr_t __read_mostly mem_hotplug;
 
 /* Private domain structs for DOMID_XEN and DOMID_IO. */
 struct domain *dom_xen, *dom_io, *dom_cow;
diff -r dd9677a90f3d -r be1d8e97cfeb xen/arch/x86/srat.c
--- a/xen/arch/x86/srat.c
+++ b/xen/arch/x86/srat.c
@@ -113,6 +113,7 @@ static __init void bad_srat(void)
 		apicid_to_node[i] = NUMA_NO_NODE;
 	for (i = 0; i < ARRAY_SIZE(pxm2node); i++)
 		pxm2node[i] = NUMA_NO_NODE;
+	mem_hotplug = 0;
 }
 
 /*
@@ -257,13 +258,6 @@ acpi_numa_memory_affinity_init(struct ac
 		return;
 	}
 	/* It is fine to add this area to the nodes data it will be used later*/
-	if (ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE)
-	{
-		printk(KERN_INFO "SRAT: hot plug zone found %"PRIx64" - %"PRIx64" \n",
-				start, end);
-		mem_hotplug = 1;
-	}
-
 	i = conflicting_memblks(start, end);
 	if (i == node) {
 		printk(KERN_WARNING
@@ -287,8 +281,11 @@ acpi_numa_memory_affinity_init(struct ac
 		if (nd->end < end)
 			nd->end = end;
 	}
-	printk(KERN_INFO "SRAT: Node %u PXM %u %"PRIx64"-%"PRIx64"\n", node, pxm,
-	       start, end);
+	if ((ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE) && end > mem_hotplug)
+		mem_hotplug = end;
+	printk(KERN_INFO "SRAT: Node %u PXM %u %"PRIx64"-%"PRIx64"%s\n",
+	       node, pxm, start, end,
+	       ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE ? " (hotplug)" : "");
 
 	node_memblk_range[num_node_memblks].start = start;
 	node_memblk_range[num_node_memblks].end = end;
diff -r dd9677a90f3d -r be1d8e97cfeb xen/arch/x86/x86_64/mm.c
--- a/xen/arch/x86/x86_64/mm.c
+++ b/xen/arch/x86/x86_64/mm.c
@@ -559,25 +559,20 @@ void __init paging_init(void)
      * We setup the L3s for 1:1 mapping if host support memory hotplug
      * to avoid sync the 1:1 mapping on page fault handler
      */
-    if ( mem_hotplug )
+    for ( va = DIRECTMAP_VIRT_START;
+          va < DIRECTMAP_VIRT_END && (void *)va < __va(mem_hotplug);
+          va += (1UL << L4_PAGETABLE_SHIFT) )
     {
-        unsigned long va;
-
-        for ( va = DIRECTMAP_VIRT_START;
-              va < DIRECTMAP_VIRT_END;
-              va += (1UL << L4_PAGETABLE_SHIFT) )
+        if ( !(l4e_get_flags(idle_pg_table[l4_table_offset(va)]) &
+              _PAGE_PRESENT) )
         {
-            if ( !(l4e_get_flags(idle_pg_table[l4_table_offset(va)]) &
-                  _PAGE_PRESENT) )
-            {
-                l3_pg = alloc_domheap_page(NULL, 0);
-                if ( !l3_pg )
-                    goto nomem;
-                l3_ro_mpt = page_to_virt(l3_pg);
-                clear_page(l3_ro_mpt);
-                l4e_write(&idle_pg_table[l4_table_offset(va)],
-                  l4e_from_page(l3_pg, __PAGE_HYPERVISOR));
-            }
+            l3_pg = alloc_domheap_page(NULL, 0);
+            if ( !l3_pg )
+                goto nomem;
+            l3_ro_mpt = page_to_virt(l3_pg);
+            clear_page(l3_ro_mpt);
+            l4e_write(&idle_pg_table[l4_table_offset(va)],
+                      l4e_from_page(l3_pg, __PAGE_HYPERVISOR));
         }
     }
 
diff -r dd9677a90f3d -r be1d8e97cfeb xen/include/asm-x86/mm.h
--- a/xen/include/asm-x86/mm.h
+++ b/xen/include/asm-x86/mm.h
@@ -399,7 +399,7 @@ static inline int get_page_and_type(stru
 int check_descriptor(const struct domain *, struct desc_struct *d);
 
 extern bool_t opt_allow_superpage;
-extern bool_t mem_hotplug;
+extern paddr_t mem_hotplug;
 
 /******************************************************************************
  * With shadow pagetables, the different kinds of address start 
