Until the xapi toolstack learns to drive the CPUID policy interface,
hard-wide libxc's default policy into every new domain

diff -r 29fdb09c98af tools/libxc/xc_dom_boot.c
--- a/tools/libxc/xc_dom_boot.c
+++ b/tools/libxc/xc_dom_boot.c
@@ -258,6 +258,10 @@ int xc_dom_boot_image(struct xc_dom_imag
     if ( (rc = arch_setup_bootlate(dom)) != 0 )
         return rc;
 
+    /* CPUID-mangling policy */
+    if ( (rc = xc_cpuid_apply_policy(dom->xch, dom->guest_domid)) != 0 )
+        return rc;
+
     /* let the vm run */
     memset(ctxt, 0, sizeof(*ctxt));
     if ( (rc = dom->arch_hooks->vcpu(dom, ctxt)) != 0 )
diff -r 29fdb09c98af tools/libxc/xc_domain_restore.c
--- a/tools/libxc/xc_domain_restore.c
+++ b/tools/libxc/xc_domain_restore.c
@@ -2401,6 +2401,11 @@ int xc_domain_restore(xc_interface *xch,
     rc = 0;
 
  out:
+
+    /* Reinstate the CPUID-mangling policy */
+    if ( rc == 0 )
+        rc = xc_cpuid_apply_policy(xch, dom);
+
     if ( (rc != 0) && (dom != 0) )
         xc_domain_destroy(xch, dom);
     xc_hypercall_buffer_free(xch, ctxt);
diff -r 29fdb09c98af tools/libxc/xc_hvm_build_x86.c
--- a/tools/libxc/xc_hvm_build_x86.c
+++ b/tools/libxc/xc_hvm_build_x86.c
@@ -526,6 +526,12 @@ static int setup_guest(xc_interface *xch
     xc_set_hvm_param(xch, dom, HVM_PARAM_NR_IOREQ_SERVER_PAGES,
                      NR_IOREQ_SERVER_PAGES);
 
+    if ( xc_cpuid_apply_policy(xch, dom) != 0 )
+    {
+        PERROR("Could not set default CPUID policy for HVM guest.\n");
+        goto error_out;
+    }
+
     /*
      * Identity-map page table is required for running with CR0.PG=0 when
      * using Intel EPT. Create a 32-bit non-PAE page directory of superpages.
