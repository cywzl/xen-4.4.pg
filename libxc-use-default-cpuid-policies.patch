Until the xapi toolstack learns to drive the CPUID policy interface,
hard-wide libxc's default policy into every new domain

diff -r b4d9a2bb56e0 tools/libxc/Makefile
--- a/tools/libxc/Makefile
+++ b/tools/libxc/Makefile
@@ -34,6 +34,7 @@ CTRL_SRCS-y       += xc_foreign_memory.c
 CTRL_SRCS-y       += xc_kexec.c
 CTRL_SRCS-y       += xtl_core.c
 CTRL_SRCS-y       += xtl_logger_stdio.c
+CTRL_SRCS-$(CONFIG_X86) += xc_cpuid_x86.c
 CTRL_SRCS-$(CONFIG_X86) += xc_pagetab.c
 CTRL_SRCS-$(CONFIG_Linux) += xc_linux.c xc_linux_osdep.c
 CTRL_SRCS-$(CONFIG_SunOS) += xc_solaris.c
@@ -69,7 +70,6 @@ GUEST_SRCS-y                 += xc_dom_b
 GUEST_SRCS-y                 += xc_dom_compat_linux.c
 
 GUEST_SRCS-$(CONFIG_X86)     += xc_dom_x86.c
-GUEST_SRCS-$(CONFIG_X86)     += xc_cpuid_x86.c
 GUEST_SRCS-$(CONFIG_X86)     += xc_hvm_build_x86.c
 GUEST_SRCS-$(CONFIG_ARM)     += xc_dom_arm.c
 GUEST_SRCS-$(CONFIG_ARM)     += xc_hvm_build_arm.c
diff -r b4d9a2bb56e0 tools/libxc/xc_dom_boot.c
--- a/tools/libxc/xc_dom_boot.c
+++ b/tools/libxc/xc_dom_boot.c
@@ -265,6 +265,10 @@ int xc_dom_boot_image(struct xc_dom_imag
     if ( (rc = arch_setup_bootlate(dom)) != 0 )
         return rc;
 
+    /* CPUID-mangling policy */
+    if ( (rc = xc_cpuid_apply_policy(dom->xch, dom->guest_domid)) != 0 )
+        return rc;
+
     /* let the vm run */
     memset(ctxt, 0, sizeof(*ctxt));
     if ( (rc = dom->arch_hooks->vcpu(dom, ctxt)) != 0 )
diff -r b4d9a2bb56e0 tools/libxc/xc_domain_restore.c
--- a/tools/libxc/xc_domain_restore.c
+++ b/tools/libxc/xc_domain_restore.c
@@ -2193,6 +2193,11 @@ int xc_domain_restore(xc_interface *xch,
     rc = 0;
 
  out:
+
+    /* Reinstate the CPUID-mangling policy */
+    if ( rc == 0 )
+        rc = xc_cpuid_apply_policy(xch, dom);
+
     if ( (rc != 0) && (dom != 0) )
         xc_domain_destroy(xch, dom);
     xc_hypercall_buffer_free(xch, ctxt);
diff -r b4d9a2bb56e0 tools/libxc/xc_hvm_build_x86.c
--- a/tools/libxc/xc_hvm_build_x86.c
+++ b/tools/libxc/xc_hvm_build_x86.c
@@ -491,6 +491,12 @@ static int setup_guest(xc_interface *xch
     xc_set_hvm_param(xch, dom, HVM_PARAM_SHARING_RING_PFN,
                      special_pfn(SPECIALPAGE_SHARING));
 
+    if ( xc_cpuid_apply_policy(xch, dom) != 0 )
+    {
+        PERROR("Could not set default CPUID policy for HVM guest.\n");
+        goto error_out;
+    }
+
     /*
      * Identity-map page table is required for running with CR0.PG=0 when
      * using Intel EPT. Create a 32-bit non-PAE page directory of superpages.
