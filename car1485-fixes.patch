Miscellaneous fixes

- check final record length, not initial one, the initial one does
  not take into account full record.
- check correctly big/little endian, IHDR_OPT_LITTLE_ENDIAN is 0
- allocate array taking into account size of elements
- check pfn readed from file to avoid possible overflow
- trying to write pages restoring set correctly rc to error instead
  of returning success (0).

diff -r 10319e8682f2 tools/libxc/saverestore/common.c
--- a/tools/libxc/saverestore/common.c	Fri Apr 04 13:11:57 2014 +0100
+++ b/tools/libxc/saverestore/common.c	Fri Apr 04 14:51:00 2014 +0100
@@ -58,7 +58,7 @@ int write_split_record(struct context *c
     uint32_t combined_length = rec->length + sz;
     size_t record_length = (combined_length + 7) & ~7UL;
 
-    if ( rec->length > REC_LENGTH_MAX )
+    if ( record_length > REC_LENGTH_MAX )
     {
         ERROR("Record (0x%08"PRIx32", %s) length 0x%"PRIx32
               " exceeds max (0x%"PRIx32")", rec->type,
diff -r 10319e8682f2 tools/libxc/saverestore/restore.c
--- a/tools/libxc/saverestore/restore.c	Fri Apr 04 13:11:57 2014 +0100
+++ b/tools/libxc/saverestore/restore.c	Fri Apr 04 14:51:00 2014 +0100
@@ -34,7 +34,7 @@ static int read_headers(struct context *
         ERROR("Invalid Version: Expected %d, Got %d", ihdr.version, IHDR_VERSION);
         return -1;
     }
-    else if ( ihdr.options & IHDR_OPT_LITTLE_ENDIAN )
+    else if ( ihdr.options & IHDR_OPT_BIG_ENDIAN )
     {
         ERROR("Unable to handle big endian streams");
         return -1;
diff -r 10319e8682f2 tools/libxc/saverestore/restore_x86_pv.c
--- a/tools/libxc/saverestore/restore_x86_pv.c	Fri Apr 04 13:11:57 2014 +0100
+++ b/tools/libxc/saverestore/restore_x86_pv.c	Fri Apr 04 14:51:00 2014 +0100
@@ -34,7 +34,7 @@ static int expand_p2m(struct context *ct
     }
     ctx->x86_pv.pfn_types = pfn_types;
 
-    p2m_pfnsz = (end_frame + 1) * sizeof *p2m;
+    p2m_pfnsz = (end_frame + 1) * sizeof *p2m_pfns;
     p2m_pfns = realloc(ctx->x86_pv.p2m_pfns, p2m_pfnsz);
     if ( !p2m_pfns )
     {
@@ -349,6 +349,11 @@ static int handle_page_data(struct conte
 
     pfn  =  page->pfn[0] & 0x0fffffffffffULL;
     type = (page->pfn[0] & 0xf000000000000000ULL) >> 32;
+    if ( pfn > ctx->x86_pv.max_pfn )
+    {
+        ERROR("Page pfn %#lx out of range", pfn);
+        goto cleanup;
+    }
     ctx->x86_pv.pfn_types[pfn] = type;
 
     /* skip invalid pages to support ballooning */
@@ -372,6 +377,7 @@ static int handle_page_data(struct conte
     if ( !guest_page || err )
     {
         PERROR("Unable to map mfn %#lx (err %d)", mfn, err);
+        rc = -1;
         goto cleanup;
     }
 
