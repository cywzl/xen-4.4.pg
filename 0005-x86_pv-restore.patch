From 7e68421b7e151271fe5378329978cb59022e94df Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Sun, 16 Mar 2014 02:09:17 +0000
Subject: [PATCH 5/5] x86_pv restore

---
 tools/libxc/saverestore/common.c         |   51 +++++++
 tools/libxc/saverestore/common.h         |   52 +++++++
 tools/libxc/saverestore/restore.c        |   89 +++++++++++-
 tools/libxc/saverestore/restore_x86_pv.c |  223 ++++++++++++++++++++++++++++++
 4 files changed, 414 insertions(+), 1 deletion(-)
 create mode 100644 tools/libxc/saverestore/restore_x86_pv.c

diff --git a/tools/libxc/saverestore/common.c b/tools/libxc/saverestore/common.c
index 6dfc47b..8314c67 100644
--- a/tools/libxc/saverestore/common.c
+++ b/tools/libxc/saverestore/common.c
@@ -77,6 +77,57 @@ int write_record(struct save_ctx *ctx, struct record *rec)
     return 0;
 }
 
+int read_record(struct restore_ctx *ctx, struct record *rec)
+{
+    xc_interface *xch = ctx->xch;
+    struct rhdr rhdr;
+    size_t datasz;
+
+    if ( read_exact(ctx->fd, &rhdr, sizeof rhdr) )
+    {
+        PERROR("Failed to read Record Header from stream");
+        return -1;
+    }
+    else if ( rhdr.length > REC_LENGTH_MAX )
+    {
+        ERROR("Record (0x%08"PRIx32", %s) length 0x%"PRIx32
+              " exceeds max (0x%"PRIx32")",
+              rhdr.type, rec_type_to_str(rhdr.type),
+              rhdr.length, REC_LENGTH_MAX);
+        return -1;
+    }
+
+    datasz = (rhdr.length + 7) & ~7U;
+
+    if ( datasz )
+    {
+        rec->data = malloc(datasz);
+
+        if ( !rec->data )
+        {
+            ERROR("Unable to allocate %zu bytes for record data (0x%08"PRIx32", %s)",
+                  datasz, rhdr.type, rec_type_to_str(rhdr.type));
+            return -1;
+        }
+
+        if ( read_exact(ctx->fd, rec->data, datasz) )
+        {
+            free(rec->data);
+            rec->data = NULL;
+            PERROR("Failed to read %zu bytes of data for record (0x%08"PRIx32", %s)",
+                   datasz, rhdr.type, rec_type_to_str(rhdr.type));
+            return -1;
+        }
+    }
+    else
+        rec->data = NULL;
+
+    rec->type   = rhdr.type;
+    rec->length = rhdr.length;
+
+    return 0;
+};
+
 /*
  * Local variables:
  * mode: C
diff --git a/tools/libxc/saverestore/common.h b/tools/libxc/saverestore/common.h
index 9d13603..a270769 100644
--- a/tools/libxc/saverestore/common.h
+++ b/tools/libxc/saverestore/common.h
@@ -59,6 +59,44 @@ struct save_ctx
 
 int save_x86_pv(struct save_ctx *ctx);
 
+struct restore_ctx
+{
+    xc_interface *xch;
+    uint32_t domid;
+    int fd;
+
+    xc_dominfo_t dominfo;
+
+    /* From Image Header */
+    uint32_t format_version;
+
+    /* From Domain Header */
+    uint32_t guest_type;
+    uint32_t guest_page_size;
+
+    union
+    {
+        struct
+        {
+            unsigned int width; /* 4 or 8; 32 or 64 bit domain */
+            unsigned int levels; /* 3 or 4 pagetable levels */
+
+            /* Frames per page in guest p2m */
+            unsigned int fpp;
+
+            /* Maximum guest frame */
+            unsigned long max_gfn;
+            /* Number of frames making up the p2m */
+            unsigned int p2m_frames;
+            /* The guest pfns containing the p2m leaves */
+            xen_pfn_t *p2m_gfns;
+
+        } x86_pv;
+    };
+};
+
+int restore_x86_pv(struct restore_ctx *ctx);
+
 struct record
 {
     uint32_t type;
@@ -75,6 +113,20 @@ struct record
  */
 int write_record(struct save_ctx *ctx, struct record *rec);
 
+/*
+ * Reads a record from the stream, and fills in the record structure.
+ *
+ * Returns 0 on success and non-0 on failure.
+ *
+ * On success, the records type and size shall be valid.
+ * - If size is 0, data shall be NULL.
+ * - If size is non-0, data shall be a buffer allocated by malloc() which must
+ *   be passed to free() by the caller.
+ *
+ * On failure, the contents of the record structure are undefined.
+ */
+int read_record(struct restore_ctx *ctx, struct record *rec);
+
 #endif
 /*
  * Local variables:
diff --git a/tools/libxc/saverestore/restore.c b/tools/libxc/saverestore/restore.c
index 6624baa..5a3f76a 100644
--- a/tools/libxc/saverestore/restore.c
+++ b/tools/libxc/saverestore/restore.c
@@ -1,5 +1,62 @@
+#include <arpa/inet.h>
+
 #include "common.h"
 
+static int read_headers(struct restore_ctx *ctx)
+{
+    xc_interface *xch = ctx->xch;
+    struct ihdr ihdr;
+    struct dhdr dhdr;
+
+    if ( read_exact(ctx->fd, &ihdr, sizeof ihdr) )
+    {
+        PERROR("Failed to read Image Header from stream");
+        return -1;
+    }
+
+    ihdr.id      = ntohl(ihdr.id);
+    ihdr.version = ntohl(ihdr.version);
+    ihdr.options = ntohs(ihdr.options);
+
+    if ( ihdr.marker != IHDR_MARKER )
+    {
+        ERROR("Invalid marker: Got 0x%016"PRIx64, ihdr.marker);
+        return -1;
+    }
+    else if ( ihdr.id != IHDR_ID )
+    {
+        ERROR("Invalid ID: Expected 0x%08"PRIx32", Got 0x%08"PRIx32,
+              IHDR_ID, ihdr.id);
+        return -1;
+    }
+    else if ( ihdr.version != IHDR_VERSION )
+    {
+        ERROR("Invalid Version: Expected %d, Got %d", ihdr.version, IHDR_VERSION);
+        return -1;
+    }
+    else if ( ihdr.options & IHDR_OPT_LITTLE_ENDIAN )
+    {
+        ERROR("Unable to handle big endian streams");
+        return -1;
+    }
+
+    ctx->format_version = ihdr.version;
+
+    if ( read_exact(ctx->fd, &dhdr, sizeof dhdr) )
+    {
+        PERROR("Failed to read Domain Header from stream");
+        return -1;
+    }
+
+    ctx->guest_type = dhdr.type;
+    ctx->guest_page_size = (1U << dhdr.page_shift);
+
+    IPRINTF("Found %s domain from Xen %d.%d",
+            dhdr_type_to_str(dhdr.type), dhdr.xen_major, dhdr.xen_minor);
+    return 0;
+}
+
+
 int xc_domain_restore2(xc_interface *xch, int io_fd, uint32_t dom,
                        unsigned int store_evtchn, unsigned long *store_mfn,
                        domid_t store_domid, unsigned int console_evtchn,
@@ -8,8 +65,38 @@ int xc_domain_restore2(xc_interface *xch, int io_fd, uint32_t dom,
                        int checkpointed_stream,
                        struct restore_callbacks *callbacks)
 {
+    struct restore_ctx ctx =
+        {
+            .xch = xch,
+            .fd = io_fd,
+        };
+
     IPRINTF("In experimental %s", __func__);
-    return -1;
+
+    if ( xc_domain_getinfo(xch, dom, 1, &ctx.dominfo) != 1 )
+    {
+        PERROR("Failed to get domain info");
+        return -1;
+    }
+
+    if ( ctx.dominfo.domid != dom )
+    {
+        ERROR("Domain %d does not exist", dom);
+        return -1;
+    }
+
+    ctx.domid = dom;
+
+    if ( read_headers(&ctx) )
+        return -1;
+
+    if ( ctx.dominfo.hvm )
+    {
+        ERROR("HVM Restore not supported yet");
+        return -1;
+    }
+    else
+        return restore_x86_pv(&ctx);
 }
 
 /*
diff --git a/tools/libxc/saverestore/restore_x86_pv.c b/tools/libxc/saverestore/restore_x86_pv.c
new file mode 100644
index 0000000..fbc9974
--- /dev/null
+++ b/tools/libxc/saverestore/restore_x86_pv.c
@@ -0,0 +1,223 @@
+#include <assert.h>
+#include <arpa/inet.h>
+
+#include "common.h"
+
+static int handle_end(struct restore_ctx *ctx, struct record *rec)
+{
+    xc_interface *xch = ctx->xch;
+
+    DPRINTF("End record");
+    return 0;
+}
+
+static int handle_x86_pv_info(struct restore_ctx *ctx, struct record *rec)
+{
+    xc_interface *xch = ctx->xch;
+    struct x86_pv_info *info = rec->data;
+
+    if ( info->guest_width != 4 &&
+         info->guest_width != 8 )
+    {
+        ERROR("Unexpected guest width %"PRIu32", Expected 4 or 8",
+              info->guest_width);
+        return -1;
+    }
+
+    if ( info->guest_width != ctx->x86_pv.width )
+    {
+        ERROR("Width of guest in stream (%"PRIu32
+              " bits) differs with existing domain (%"PRIu32" bits)",
+              info->guest_width * 8, ctx->x86_pv.width * 8);
+        return -1;
+    }
+
+    if ( info->pt_levels != 3 &&
+         info->pt_levels != 4 )
+    {
+        ERROR("Unexpected guest levels %"PRIu32", Expected 3 or 4",
+              info->pt_levels);
+        return -1;
+    }
+
+    if ( info->pt_levels != ctx->x86_pv.levels )
+    {
+        ERROR("Levels of guest in stream (%"PRIu32
+              ") differs with existing domain (%"PRIu32")",
+              info->pt_levels, ctx->x86_pv.levels);
+        return -1;
+    }
+
+
+    DPRINTF("X86_PV_INFO record: %d bits, %d levels",
+            ctx->x86_pv.width * 8, ctx->x86_pv.levels);
+    return 0;
+}
+
+static int handle_x86_pv_p2m_frames(struct restore_ctx *ctx, struct record *rec)
+{
+    xc_interface *xch = ctx->xch;
+    struct x86_pv_p2m_frames *data = rec->data;
+    unsigned start, end, x;
+
+    if ( !ctx->x86_pv.p2m_gfns )
+    {
+        ctx->x86_pv.p2m_gfns = malloc(ctx->x86_pv.p2m_frames * sizeof(xen_pfn_t));
+        if ( !ctx->x86_pv.p2m_gfns )
+        {
+            ERROR("Cannot allocate %zu bytes for p2m pfns list",
+                  ctx->x86_pv.p2m_frames * sizeof(xen_pfn_t));
+            return -1;
+        }
+    }
+
+    if ( data->end_gfn > ctx->x86_pv.max_gfn )
+    {
+        ERROR("End gfn in stream (%#"PRIx32") exceeds domain max (%#lx)",
+              data->end_gfn, ctx->x86_pv.max_gfn);
+        return -1;
+    }
+    else if ( data->start_gfn > data->end_gfn )
+    {
+        ERROR("End gfn in stream (%#"PRIx32") exceeds Start (%#"PRIx32")",
+              data->end_gfn, data->start_gfn);
+        return -1;
+    }
+
+    start = data->start_gfn / ctx->x86_pv.fpp;
+    end = (data->end_gfn + ctx->x86_pv.fpp) / ctx->x86_pv.fpp;
+
+    for ( x = 0; x < (end - start); ++x )
+        ctx->x86_pv.p2m_gfns[start + x] = data->p2m_gfns[x];
+
+    DPRINTF("X86_PV_P2M_FRAMES record: GFNs %#"PRIx32"->%#"PRIx32,
+            data->start_gfn, data->end_gfn);
+
+    return 0;
+}
+
+static int get_basic_info(struct restore_ctx *ctx)
+{
+    xc_interface *xch = ctx->xch;
+    unsigned int guest_width;
+    int max_gfn;
+
+    if ( xc_domain_get_guest_width(xch, ctx->domid, &guest_width) )
+    {
+        PERROR("Unable to determine dom%d's width", ctx->domid);
+        return -1;
+    }
+    ctx->x86_pv.width = guest_width;
+
+    if ( ctx->x86_pv.width == 4 )
+        ctx->x86_pv.levels = 3;
+    else if ( ctx->x86_pv.width == 8 )
+        ctx->x86_pv.levels = 4;
+    else
+    {
+        ERROR("Invalid guest width %d.  Expected 32 or 64", ctx->x86_pv.width);
+        return -1;
+    }
+    ctx->x86_pv.fpp = PAGE_SIZE/guest_width;
+
+    max_gfn = xc_domain_maximum_gpfn(xch, ctx->domid);
+    if ( max_gfn <= 0 )
+    {
+        PERROR("Unable to obtain guests max gfn");
+        return -1;
+    }
+    ctx->x86_pv.max_gfn = max_gfn;
+    ctx->x86_pv.p2m_frames = (ctx->x86_pv.max_gfn + ctx->x86_pv.fpp) / ctx->x86_pv.fpp;
+
+    DPRINTF("Guest max gfn: %#lx, p2m_frames: %d", ctx->x86_pv.max_gfn, ctx->x86_pv.p2m_frames);
+
+    return 0;
+}
+
+int restore_x86_pv(struct restore_ctx *ctx)
+{
+    xc_interface *xch = ctx->xch;
+    struct record rec;
+    int rc;
+
+    IPRINTF("In experimental %s", __func__);
+
+    if ( ctx->guest_type != DHDR_TYPE_x86_pv )
+    {
+        ERROR("Unable to restore %s domain into an x86_pv domain",
+              dhdr_type_to_str(ctx->guest_type));
+        return -1;
+    }
+    else if ( ctx->guest_page_size != 4096 )
+    {
+        ERROR("Invalid page size %d for x86_pv domains", ctx->guest_page_size);
+        return -1;
+    }
+
+    rc = get_basic_info(ctx);
+    if ( rc )
+        goto err;
+
+    do
+    {
+        rc = read_record(ctx, &rec);
+        if ( rc )
+            goto err;
+
+        switch ( rec.type )
+        {
+        case REC_TYPE_end:
+            rc = handle_end(ctx, &rec);
+            break;
+
+        case REC_TYPE_x86_pv_info:
+            rc = handle_x86_pv_info(ctx, &rec);
+            break;
+
+        case REC_TYPE_x86_pv_p2m_frames:
+            rc = handle_x86_pv_p2m_frames(ctx, &rec);
+            break;
+
+        default:
+            if ( rec.type & REC_TYPE_optional )
+            {
+                IPRINTF("Ignoring optional record (0x%"PRIx32", %s)",
+                        rec.type, rec_type_to_str(rec.type));
+                rc = 0;
+                break;
+            }
+
+            ERROR("Invalid record type (0x%"PRIx32", %s) for x86_pv domains",
+                  rec.type, rec_type_to_str(rec.type));
+            rc = -1;
+            break;
+        }
+
+        free(rec.data);
+        if ( rc )
+            goto err;
+
+    } while ( rec.type != REC_TYPE_end );
+
+    /* all done */
+    assert(!rc);
+    goto cleanup;
+
+ err:
+    assert(rc);
+ cleanup:
+
+    free(ctx->x86_pv.p2m_gfns);
+
+    return rc;
+}
+
+/*
+ * Local variables:
+ * mode: C
+ * c-file-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
-- 
1.7.10.4

