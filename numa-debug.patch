diff -r a6b6c598eaed xen/arch/x86/setup.c
--- a/xen/arch/x86/setup.c
+++ b/xen/arch/x86/setup.c
@@ -186,9 +186,12 @@ extern char __init_begin[], __init_end[]
 
 static void __init init_idle_domain(void)
 {
+    printk("** Pre scheduler_init()\n");
     scheduler_init();
+    printk("** setting current\n");
     set_current(idle_vcpu[0]);
     this_cpu(curr_vcpu) = current;
+    printk("** done init_idle()\n");
 }
 
 void __devinit srat_detect_node(int cpu)
@@ -1255,6 +1258,8 @@ void __init __start_xen(unsigned long mb
 
     timer_init();
 
+    printk("**Passed timer init\n");
+
     init_idle_domain();
 
     trap_init();
diff -r a6b6c598eaed xen/arch/x86/traps.c
--- a/xen/arch/x86/traps.c
+++ b/xen/arch/x86/traps.c
@@ -1468,14 +1468,18 @@ void __init do_early_page_fault(struct c
 
     if ( stuck++ == 1000 )
     {
-        unsigned long *stk = (unsigned long *)regs;
+        /* unsigned long *stk = (unsigned long *)regs; */
         printk("Early fatal page fault at %04x:%p (cr2=%p, ec=%04x)\n", 
                regs->cs, _p(regs->eip), _p(cr2), regs->error_code);
         show_page_walk(cr2);
-        printk("Stack dump: ");
-        while ( ((long)stk & ((PAGE_SIZE - 1) & ~(BYTES_PER_LONG - 1))) != 0 )
-            printk("%p ", _p(*stk++));
-        for ( ; ; ) ;
+
+        show_trace(regs);
+
+        /* printk("Stack dump: "); */
+        /* while ( ((long)stk & ((PAGE_SIZE - 1) & ~(BYTES_PER_LONG - 1))) != 0 ) */
+        /*     printk("%p ", _p(*stk++)); */
+        for ( ; ; )
+            halt();
     }
 }
 
diff -r a6b6c598eaed xen/common/domain.c
--- a/xen/common/domain.c
+++ b/xen/common/domain.c
@@ -202,6 +202,9 @@ struct domain *domain_create(
            INIT_evtchn = 1u<<3, INIT_gnttab = 1u<<4, INIT_arch = 1u<<5 };
     int err, init_status = 0;
     int poolid = CPUPOOLID_NONE;
+    static int location = 0;
+
+    printk("*** LOC A\n");
 
     if ( (d = alloc_domain_struct()) == NULL )
         return ERR_PTR(-ENOMEM);
@@ -210,25 +213,48 @@ struct domain *domain_create(
 
     lock_profile_register_struct(LOCKPROF_TYPE_PERDOM, d, domid, "Domain");
 
+    printk("*** LOC B\n");
     if ( (err = xsm_alloc_security_domain(d)) != 0 )
         goto fail;
     init_status |= INIT_xsm;
 
+    printk("*** LOC C\n");
     watchdog_domain_init(d);
     init_status |= INIT_watchdog;
 
+    printk("Domain pointer: %p\n", d);
+
+    printk("*** LOC D\n");
     atomic_set(&d->refcnt, 1);
+
+    asm volatile ("xorq %%r15,%%r15" : : : "r15");
+    printk("*** LOC %d\n", location++);
+    asm volatile ("xorq %%r15,%%r15" : : : "r15");
+
     spin_lock_init_prof(d, domain_lock);
+
+    asm volatile ("xorq %%r15,%%r15" : : : "r15");
+    printk("*** LOC %d\n", location++);
+    asm volatile ("xorq %%r15,%%r15" : : : "r15");
+
+    printk("*** LOC %d\n", location++);
     spin_lock_init_prof(d, page_alloc_lock);
+    printk("*** LOC %d\n", location++);
     spin_lock_init(&d->hypercall_deadlock_mutex);
+    printk("*** LOC %d\n", location++);
     spin_lock_init(&d->runstate_lock);
+    printk("*** LOC %d\n", location++);
     INIT_PAGE_LIST_HEAD(&d->page_list);
+    printk("*** LOC %d\n", location++);
     INIT_PAGE_LIST_HEAD(&d->xenpage_list);
+    printk("*** LOC %d\n", location++);
 
+    printk("*** LOC E\n");
     spin_lock_init(&d->node_affinity_lock);
     d->node_affinity = NODE_MASK_ALL;
     d->auto_node_affinity = 1;
 
+    printk("*** LOC F\n");
     spin_lock_init(&d->shutdown_lock);
     d->shutdown_code = -1;
 
@@ -236,15 +262,18 @@ struct domain *domain_create(
     if ( !zalloc_cpumask_var(&d->domain_dirty_cpumask) )
         goto fail;
 
+    printk("*** LOC %d\n", location++);
     if ( domcr_flags & DOMCRF_hvm )
         d->is_hvm = 1;
 
+    printk("*** LOC %d\n", location++);
     if ( domid == 0 )
     {
         d->is_pinned = opt_dom0_vcpus_pin;
         d->disable_migrate = 1;
     }
 
+    printk("*** LOC %d\n", location++);
     rangeset_domain_initialise(d);
     init_status |= INIT_rangeset;
 
@@ -253,6 +282,7 @@ struct domain *domain_create(
     if ( (d->iomem_caps == NULL) || (d->irq_caps == NULL) )
         goto fail;
 
+    printk("*** LOC %d\n", location++);
     if ( domcr_flags & DOMCRF_dummy )
         return d;
 
@@ -288,6 +318,7 @@ struct domain *domain_create(
         if ( !d->mem_event )
             goto fail;
     }
+    printk("*** LOC %d\n", location++);
 
     if ( (err = arch_domain_create(d, domcr_flags)) != 0 )
         goto fail;
@@ -299,6 +330,7 @@ struct domain *domain_create(
     if ( (err = sched_init_domain(d)) != 0 )
         goto fail;
 
+    printk("*** LOC %d\n", location++);
     if ( !is_idle_domain(d) )
     {
         spin_lock(&domlist_update_lock);
@@ -316,6 +348,7 @@ struct domain *domain_create(
     return d;
 
  fail:
+    printk("*** FAILED!! %d\n", location++);
     d->is_dying = DOMDYING_dead;
     atomic_set(&d->refcnt, DOMAIN_DESTROYED);
     xfree(d->mem_event);
@@ -340,8 +373,15 @@ struct domain *domain_create(
     return ERR_PTR(err);
 }
 
+static void nodeset_print(char *set, int size, const nodemask_t *mask)
+{
+    *set++ = '[';
+    set += nodelist_scnprintf(set, size-2, mask);
+    *set++ = ']';
+    *set++ = '\0';
+}
 
-void domain_update_node_affinity(struct domain *d)
+void noinline domain_update_node_affinity(struct domain *d)
 {
     cpumask_var_t cpumask;
     cpumask_var_t online_affinity;
@@ -349,6 +389,8 @@ void domain_update_node_affinity(struct 
     struct vcpu *v;
     unsigned int node;
 
+    char tmpstr[256];
+
     if ( !zalloc_cpumask_var(&cpumask) )
         return;
     if ( !alloc_cpumask_var(&online_affinity) )
@@ -386,6 +428,9 @@ void domain_update_node_affinity(struct 
 
     spin_unlock(&d->node_affinity_lock);
 
+    nodeset_print(tmpstr, sizeof(tmpstr), &d->node_affinity);
+    printk("--VCPU: %d, d->node_affinity: %s\n", v->vcpu_id, tmpstr);
+
     free_cpumask_var(online_affinity);
     free_cpumask_var(cpumask);
 }
diff -r a6b6c598eaed xen/common/schedule.c
--- a/xen/common/schedule.c
+++ b/xen/common/schedule.c
@@ -1476,10 +1476,12 @@ void __init scheduler_init(void)
         sched_ratelimit_us = SCHED_DEFAULT_RATELIMIT_US;
     }
 
+    printk("About to allocate the idle domain\n");
     idle_domain = domain_create(DOMID_IDLE, 0, 0);
     BUG_ON(IS_ERR(idle_domain));
     idle_domain->vcpu = idle_vcpu;
     idle_domain->max_vcpus = nr_cpu_ids;
+    printk("About to allocate a vcpu for the idle domain\n");
     if ( alloc_vcpu(idle_domain, 0, 0) == NULL )
         BUG();
     if ( ops.alloc_pdata &&
