# HG changeset patch
# Parent 357ff1f711a969467978a70b61aa5038f98d99bb

diff -r 357ff1f711a9 tools/firmware/hvmloader/acpi/acpi2_0.h
--- a/tools/firmware/hvmloader/acpi/acpi2_0.h
+++ b/tools/firmware/hvmloader/acpi/acpi2_0.h
@@ -303,6 +303,10 @@ struct acpi_20_waet {
     struct acpi_header header;
     uint32_t           flags;
 };
+#define ACPI_WAET_RTC_NO_ACK        (1<<0) /* RTC requires no int acknowledge */
+#define ACPI_WAET_TIMER_ONE_READ    (1<<1) /* PM timer requires only one read */
+
+#define ACPI_WAET_DEFAULT_FLAGS (ACPI_WAET_TIMER_ONE_READ)
 
 /*
  * Multiple APIC Flags.
diff -r 357ff1f711a9 tools/firmware/hvmloader/acpi/build.c
--- a/tools/firmware/hvmloader/acpi/build.c
+++ b/tools/firmware/hvmloader/acpi/build.c
@@ -23,6 +23,8 @@
 #include "ssdt_pm.h"
 #include "../config.h"
 #include "../util.h"
+#include "../hypercall.h"
+#include <xen/hvm/params.h>
 #include <xen/hvm/hvm_xs_strings.h>
 
 #define ACPI_MAX_SECONDARY_TABLES 16
@@ -189,6 +191,9 @@ static struct acpi_20_hpet *construct_hp
 static struct acpi_20_waet *construct_waet(void)
 {
     struct acpi_20_waet *waet;
+    const char *s;
+    struct xen_hvm_param p =
+        { .domid = DOMID_SELF, .index = HVM_PARAM_RTC_MODE };
 
     waet = mem_alloc(sizeof(*waet), 16);
     if (!waet) return NULL;
@@ -196,8 +201,35 @@ static struct acpi_20_waet *construct_wa
     memcpy(waet, &Waet, sizeof(*waet));
 
     waet->header.length = sizeof(*waet);
+
+    s = xenstore_read("platform/waet-rtc-noack", NULL);
+    if ( s )
+    {
+        if ( !strncmp(s, "1", 1) || !strncmp(s, "true", 4) )
+            waet->flags |= ACPI_WAET_RTC_NO_ACK;
+        else
+            waet->flags &= ~ACPI_WAET_RTC_NO_ACK;
+    }
+
+    s = xenstore_read("platform/waet-pm-reliable", NULL);
+    if ( s )
+    {
+        if ( !strncmp(s, "1", 1) || !strncmp(s, "true", 4) )
+            waet->flags |= ACPI_WAET_TIMER_ONE_READ;
+        else
+            waet->flags &= ~ACPI_WAET_TIMER_ONE_READ;
+    }
+
+    printf("WAET flags: RTC noack %d, PM reliable %d\n",
+           !!(waet->flags & ACPI_WAET_RTC_NO_ACK),
+           !!(waet->flags & ACPI_WAET_TIMER_ONE_READ));
+
     set_checksum(waet, offsetof(struct acpi_header, checksum), sizeof(*waet));
 
+    /* Inform Xen which RTC mode has been chosen */
+    p.value = !!(waet->flags & ACPI_WAET_RTC_NO_ACK);
+    hypercall_hvm_op(HVMOP_set_param, &p);
+
     return waet;
 }
 
diff -r 357ff1f711a9 tools/firmware/hvmloader/acpi/static_tables.c
--- a/tools/firmware/hvmloader/acpi/static_tables.c
+++ b/tools/firmware/hvmloader/acpi/static_tables.c
@@ -136,16 +136,6 @@ struct acpi_20_rsdp Rsdp = {
     .length    = sizeof(struct acpi_20_rsdp)
 };
 
-#define ACPI_WAET_RTC_NO_ACK        (1<<0) /* RTC requires no int acknowledge */
-#define ACPI_WAET_TIMER_ONE_READ    (1<<1) /* PM timer requires only one read */
-
-/*
- * The state of the RTC flag getting passed to the guest must be in
- * sync with the mode selection in the hypervisor RTC emulation code.
- */
-#define ACPI_WAET_FLAGS (ACPI_WAET_RTC_NO_ACK | \
-                         ACPI_WAET_TIMER_ONE_READ)
-
 struct acpi_20_waet Waet = {
     .header = {
         .signature    = ACPI_2_0_WAET_SIGNATURE,
@@ -157,7 +147,7 @@ struct acpi_20_waet Waet = {
         .creator_id   = ACPI_CREATOR_ID,
         .creator_revision = ACPI_CREATOR_REVISION
     },
-    .flags = ACPI_WAET_FLAGS
+    .flags = ACPI_WAET_DEFAULT_FLAGS
 };
 
 /*
