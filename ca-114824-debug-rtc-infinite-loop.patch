# HG changeset patch
# Parent dd1a553e4d13857f2e7fb1a8d0a49ba01e4b8d47

diff -r dd1a553e4d13 tools/misc/xen-hvmctx.c
--- a/tools/misc/xen-hvmctx.c
+++ b/tools/misc/xen-hvmctx.c
@@ -307,6 +307,7 @@ static void dump_pit(void)
 
 static void dump_rtc(void)
 {
+    uint8_t v;
     HVM_SAVE_TYPE(RTC) r;
     READ(r);
     printf("    RTC: regs 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n",
@@ -316,6 +317,68 @@ static void dump_rtc(void)
            r.cmos_data[8], r.cmos_data[9], r.cmos_data[10], r.cmos_data[11], 
            r.cmos_data[12], r.cmos_data[13], r.cmos_index);
 
+    if ( r.cmos_data[0xb] & 0x2 ) // Binary mode
+    {
+        printf("    RTC decode (binary)\n");
+        printf("         Current time:  %02d:%02d:%02d\n",
+               r.cmos_data[4], r.cmos_data[2], r.cmos_data[0]);
+        printf("         Current alarm: %02d:%02d:%02d\n",
+               r.cmos_data[5], r.cmos_data[3], r.cmos_data[1]);
+        printf("         Current date:  y %d, m %d, d %d, day of week %d\n",
+               r.cmos_data[9], r.cmos_data[8], r.cmos_data[7], r.cmos_data[6]);
+    }
+    else // BCD mode
+    {
+        printf("    RTC decode (bcd)\n");
+        printf("         Current time:  %x%x:%x%x:%x%x\n",
+               r.cmos_data[4] >> 4, r.cmos_data[4] & 0xf,
+               r.cmos_data[2] >> 4, r.cmos_data[2] & 0xf,
+               r.cmos_data[0] >> 4, r.cmos_data[0] & 0xf
+            );
+        printf("         Current alarm: %x%x:%x%x:%x%x\n",
+               r.cmos_data[5] >> 4, r.cmos_data[5] & 0xf,
+               r.cmos_data[3] >> 4, r.cmos_data[3] & 0xf,
+               r.cmos_data[1] >> 4, r.cmos_data[1] & 0xf
+            );
+        printf("         Current date:  y %x%x, m %x%x, d %x%x, day of week %x%x\n",
+               r.cmos_data[9] >> 4, r.cmos_data[9] & 0xf,
+               r.cmos_data[8] >> 4, r.cmos_data[8] & 0xf,
+               r.cmos_data[7] >> 4, r.cmos_data[7] & 0xf,
+               r.cmos_data[6] >> 4, r.cmos_data[6] & 0xf
+            );
+    }
+
+    v = r.cmos_data[0xa];
+    printf("         REG A: 0x%02x - UIP%c\n",
+           v, v & 0x80 ? '+' : '-');
+
+    v = r.cmos_data[0xb];
+    printf("         REG B: 0x%02x - %s %s %s %s %s %s %s %s\n", v,
+           v & 0x80 ? "SET" : "",
+           v & 0x40 ? "PIE" : "",
+           v & 0x20 ? "AIE" : "",
+           v & 0x10 ? "UIE" : "",
+           v & 0x08 ? "SQWE" : "",
+           v & 0x04 ? "DM" : "",
+           v & 0x02 ? "24" : "12",
+           v & 0x01 ? "DSE" : ""
+        );
+
+    v = r.cmos_data[0xc];
+    printf("         REG C: 0x%02x - %s %s %s %s %s\n", v,
+           v & 0x80 ? "IRQF" : "",
+           v & 0x40 ? "PF" : "",
+           v & 0x20 ? "AF" : "",
+           v & 0x10 ? "UF" : "",
+           v & 0x0f ? "RAZ invalid" : ""
+        );
+
+    v = r.cmos_data[0xd];
+    printf("         REG D: 0x%02x - %s %s\n", v,
+           v & 0x80 ? "VRT" : "",
+           v & 0x7f ? "RAZ invalid" : ""
+        );
+
 }
 
 static void dump_hpet(void)
diff -r dd1a553e4d13 xen/arch/x86/hvm/rtc.c
--- a/xen/arch/x86/hvm/rtc.c
+++ b/xen/arch/x86/hvm/rtc.c
@@ -467,6 +467,9 @@ static int rtc_ioport_write(void *opaque
             rtc_timer_update(s);
         break;
     case RTC_REG_B:
+        if ( (data ^ s->hw.cmos_data[RTC_REG_B]) & RTC_DM_BINARY )
+            gdprintk(XENLOG_INFO, "** Guest changed RTC[B].DM.  Now %d\n",
+                     !!(data & RTC_DM_BINARY));
         if ( data & RTC_SET )
         {
             /* set mode: reset UIP mode */
diff -r dd1a553e4d13 xen/arch/x86/hvm/vpt.c
--- a/xen/arch/x86/hvm/vpt.c
+++ b/xen/arch/x86/hvm/vpt.c
@@ -585,3 +585,79 @@ void pt_may_unmask_irq(struct domain *d,
     if ( vlapic_pt )
         pt_resume(vlapic_pt);
 }
+
+static void dump_pt(const struct periodic_time *pt)
+{
+    printk("PT(%p) %p(%p) d%dv%d 0x%02x(%u) %c%c%c%c%c "
+           "N%u P%"PRIu64" S%"PRId64" L%"PRIu64"\n",
+           _p(pt),
+           _p(pt->cb),
+           _p(pt->priv),
+
+           pt->vcpu->domain->domain_id,
+           pt->vcpu->vcpu_id,
+
+           pt->irq,
+           pt->source,
+
+           pt->on_list ? 'l' : ' ',
+           pt->one_shot ? '1' : 'p',
+           pt->do_not_freeze ? 'F' : ' ',
+           pt->irq_issued ? 'i' : ' ',
+           pt->warned_timeout_too_short ? 'W' : ' ',
+
+           pt->pending_intr_nr,
+           pt->period,
+           pt->scheduled,
+           pt->last_plt_gtime
+        );
+}
+
+#include <xen/keyhandler.h>
+
+static void dump_all_periodic_timers(unsigned char ch)
+{
+    struct domain *d;
+    struct vcpu *v;
+    struct list_head *head;
+    struct periodic_time *pt;
+
+    printk("'%c' pressed - dumping all HVM domain periodic timers\n", ch);
+
+    rcu_read_lock(&domlist_read_lock);
+
+    for_each_domain ( d )
+    {
+        if ( !is_hvm_domain(d) )
+            continue;
+
+        printk(">>> Domain %d <<<\n", d->domain_id);
+        for_each_vcpu ( d, v )
+        {
+            printk("  VCPU %d\n", v->vcpu_id);
+            spin_lock(&v->arch.hvm_vcpu.tm_lock);
+
+            head = &v->arch.hvm_vcpu.tm_list;
+
+            list_for_each_entry ( pt, head, list )
+                dump_pt(pt);
+
+            spin_unlock(&v->arch.hvm_vcpu.tm_lock);
+        }
+    }
+
+    rcu_read_unlock(&domlist_read_lock);
+}
+
+struct keyhandler dump_periodic_timers_keyhandler = {
+    .diagnostic = 0,
+    .u.fn = dump_all_periodic_timers,
+    .desc = "dump all periodic timers"
+};
+
+static int __init setup_dump_periodic_timers(void)
+{
+    register_keyhandler('1', &dump_periodic_timers_keyhandler);
+    return 0;
+}
+__initcall(setup_dump_periodic_timers);
